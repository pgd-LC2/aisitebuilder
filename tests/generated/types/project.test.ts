// AUTO-GENERATED BY generate-tests.ts
// Source: src/types/project.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import {
  ProjectStatus,
  Project,
  ProjectVersion,
  BuildLogType,
  BuildLog,
  MessageRole,
  ChatMessage,
  FileCategory,
  FileSourceType,
  ProjectFile,
  FileUploadProgress,
  FileTreeNode,
  ProjectFilesContext,
  AITaskType,
  AITaskStatus,
  AITask,
  PromptCategory,
  Prompt,
  WorkflowMode,
  PlanSummary,
  WorkflowState,
} from '../../../src/types/project';

describe('ProjectStatus', () => {
  test.each([
    ['draft'],
    ['building'],
    ['completed'],
    ['failed'],
  ] as const)('should accept status "%s"', (status) => {
    const validStatus: ProjectStatus = status;
    expect(validStatus).toBe(status);
  });
});

describe('Project', () => {
  const validProject: Project = {
    id: 'proj_1',
    user_id: 'user_1',
    title: 'Test Project',
    description: 'A project for testing',
    status: 'draft',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  test('should create a valid Project object', () => {
    expect(validProject.id).toBeString();
    expect(validProject.user_id).toBeString();
    expect(validProject.title).toBeString();
    expect(validProject.description).toBeString();
    expect(['draft', 'building', 'completed', 'failed']).toContain(validProject.status);
    expect(validProject.created_at).toBeString();
    expect(validProject.updated_at).toBeString();
  });

  test('should allow empty strings for optional fields', () => {
    const emptyProject = { ...validProject, title: '', description: '' };
    expect(emptyProject.title).toBe('');
    expect(emptyProject.description).toBe('');
  });
});

describe('ProjectVersion', () => {
  const validVersion: ProjectVersion = {
    id: 'ver_1',
    project_id: 'proj_1',
    version_number: 1,
    code_snapshot: { main: 'console.log("hi");' },
    created_at: new Date().toISOString(),
  };

  test('should create a valid ProjectVersion object', () => {
    expect(validVersion.id).toBeString();
    expect(validVersion.project_id).toBeString();
    expect(validVersion.version_number).toBeNumber();
    expect(validVersion.code_snapshot).toBeObject();
    expect(validVersion.created_at).toBeString();
  });

  test('should accept optional fields', () => {
    const withOptional = {
      ...validVersion,
      preview_url: 'https://preview.com',
      storage_path: '/path/to/storage',
      total_files: 10,
      total_size: 2048,
    };
    expect(withOptional.preview_url).toBeString();
    expect(withOptional.storage_path).toBeString();
    expect(withOptional.total_files).toBeNumber();
    expect(withOptional.total_size).toBeNumber();
  });
});

describe('BuildLog', () => {
  const validLog: BuildLog = {
    id: 'log_1',
    project_id: 'proj_1',
    log_type: 'info',
    message: 'Build started',
    created_at: new Date().toISOString(),
  };

  test.each([
    ['info'],
    ['success'],
    ['error'],
  ] as const)('should accept log_type "%s"', (type) => {
    const log: BuildLog = { ...validLog, log_type: type };
    expect(log.log_type).toBe(type);
  });

  test('should create a valid BuildLog object', () => {
    expect(validLog.id).toBeString();
    expect(validLog.project_id).toBeString();
    expect(['info', 'success', 'error']).toContain(validLog.log_type);
    expect(validLog.message).toBeString();
    expect(validLog.created_at).toBeString();
  });
});

describe('ChatMessage', () => {
  const validMessage: ChatMessage = {
    id: 'msg_1',
    project_id: 'proj_1',
    role: 'user',
    content: 'Hello',
    created_at: new Date().toISOString(),
  };

  test.each([
    ['user'],
    ['assistant'],
  ] as const)('should accept role "%s"', (role) => {
    const msg: ChatMessage = { ...validMessage, role };
    expect(msg.role).toBe(role);
  });

  test('should create a valid ChatMessage object', () => {
    expect(validMessage.id).toBeString();
    expect(validMessage.project_id).toBeString();
    expect(['user', 'assistant']).toContain(validMessage.role);
    expect(validMessage.content).toBeString();
    expect(validMessage.created_at).toBeString();
  });
});

describe('ProjectFile', () => {
  const validFile: ProjectFile = {
    id: 'file_1',
    project_id: 'proj_1',
    file_name: 'index.js',
    file_path: '/src/index.js',
    file_size: 123,
    mime_type: 'application/javascript',
    file_category: 'code',
    source_type: 'user_upload',
    is_public: false,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  test.each([
    ['code'],
    ['asset'],
    ['document'],
    ['build'],
  ] as const)('should accept file_category "%s"', (category) => {
    const file: ProjectFile = { ...validFile, file_category: category };
    expect(file.file_category).toBe(category);
  });

  test.each([
    ['user_upload'],
    ['ai_generated'],
  ] as const)('should accept source_type "%s"', (type) => {
    const file: ProjectFile = { ...validFile, source_type: type };
    expect(file.source_type).toBe(type);
  });

  test('should create a valid ProjectFile object', () => {
    expect(validFile.id).toBeString();
    expect(validFile.project_id).toBeString();
    expect(validFile.file_name).toBeString();
    expect(validFile.file_path).toBeString();
    expect(validFile.file_size).toBeNumber();
    expect(validFile.mime_type).toBeString();
    expect(['code', 'asset', 'document', 'build']).toContain(validFile.file_category);
    expect(['user_upload', 'ai_generated']).toContain(validFile.source_type);
    expect(validFile.is_public).toBeBoolean();
    expect(validFile.created_at).toBeString();
    expect(validFile.updated_at).toBeString();
  });

  test('should accept optional fields', () => {
    const withOptional: ProjectFile = {
      ...validFile,
      public_url: 'https://public.com/file.js',
      share_expires_at: new Date(Date.now() + 86400000).toISOString(),
    };
    expect(withOptional.public_url).toBeString();
    expect(withOptional.share_expires_at).toBeString();
  });
});

describe('FileUploadProgress', () => {
  const dummyFile = new File(['content'], 'test.txt', { type: 'text/plain' });

  const validProgress: FileUploadProgress = {
    file: dummyFile,
    progress: 0,
    status: 'pending',
  };

  test.each([
    ['pending'],
    ['uploading'],
    ['success'],
    ['error'],
  ] as const)('should accept status "%s"', (status) => {
    const prog: FileUploadProgress = { ...validProgress, status };
    expect(prog.status).toBe(status);
  });

  test('should create a valid FileUploadProgress object', () => {
    expect(validProgress.file).toBeInstanceOf(File);
    expect(validProgress.progress).toBeNumber();
    expect(validProgress.status).toBe('pending');
  });

  test('should accept optional error and result', () => {
    const withOptional: FileUploadProgress = {
      ...validProgress,
      status: 'error',
      error: 'Network error',
      result: {
        id: 'file_2',
        project_id: 'proj_1',
        file_name: 'test.txt',
        file_path: '/uploads/test.txt',
        file_size: 10,
        mime_type: 'text/plain',
        file_category: 'document',
        source_type: 'user_upload',
        is_public: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
    };
    expect(withOptional.error).toBeString();
    expect(withOptional.result).toBeDefined();
  });
});

describe('FileTreeNode', () => {
  const fileNode: FileTreeNode = {
    name: 'file.js',
    path: '/src/file.js',
    type: 'file',
    size: 123,
    mimeType: 'application/javascript',
    file: {
      id: 'file_3',
      project_id: 'proj_1',
      file_name: 'file.js',
      file_path: '/src/file.js',
      file_size: 123,
      mime_type: 'application/javascript',
      file_category: 'code',
      source_type: 'user_upload',
      is_public: false,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    },
  };

  const folderNode: FileTreeNode = {
    name: 'src',
    path: '/src',
    type: 'folder',
    children: [fileNode],
  };

  test('should create a file node', () => {
    expect(fileNode.type).toBe('file');
    expect(fileNode.name).toBeString();
    expect(fileNode.path).toBeString();
    expect(fileNode.size).toBeNumber();
    expect(fileNode.mimeType).toBeString();
    expect(fileNode.file).toBeDefined();
  });

  test('should create a folder node', () => {
    expect(folderNode.type).toBe('folder');
    expect(folderNode.name).toBeString();
    expect(folderNode.path).toBeString();
    expect(folderNode.children).toBeArray();
    expect(folderNode.children?.length).toBe(1);
  });
});

describe('ProjectFilesContext', () => {
  const validContext: ProjectFilesContext = {
    bucket: 'my-bucket',
    path: '/projects/proj_1',
    versionId: 'ver_1',
    versionNumber: 1,
  };

  test('should create a valid ProjectFilesContext object', () => {
    expect(validContext.bucket).toBeString();
    expect(validContext.path).toBeString();
    expect(validContext.versionId).toBeString();
    expect(validContext.versionNumber).toBeNumber();
  });

  test('should allow omission of optional fields', () => {
    const minimal: ProjectFilesContext = {
      bucket: 'my-bucket',
      path: '/projects/proj_1',
    };
    expect(minimal.versionId).toBeUndefined();
    expect(minimal.versionNumber).toBeUndefined();
  });
});

describe('AITask', () => {
  const validTask: AITask = {
    id: 'task_1',
    project_id: 'proj_1',
    user_id: 'user_1',
    type: 'chat_reply',
    payload: { question: 'What is AI?' },
    status: 'queued',
    created_at: new Date().toISOString(),
  };

  test.each([
    ['chat_reply'],
    ['build_site'],
    ['refactor_code'],
  ] as const)('should accept type "%s"', (type) => {
    const task: AITask = { ...validTask, type };
    expect(task.type).toBe(type);
  });

  test.each([
    ['queued'],
    ['running'],
    ['completed'],
    ['failed'],
    ['cancelled'],
  ] as const)('should accept status "%s"', (status) => {
    const task: AITask = { ...validTask, status };
    expect(task.status).toBe(status);
  });

  test('should create a valid AITask object', () => {
    expect(validTask.id).toBeString();
    expect(validTask.project_id).toBeString();
    expect(validTask.user_id).toBeString();
    expect(validTask.type).toBe('chat_reply');
    expect(validTask.payload).toBeObject();
    expect(validTask.status).toBe('queued');
    expect(validTask.created_at).toBeString();
  });

  test('should accept optional result, model, error, started_at, finished_at', () => {
    const withOptional: AITask = {
      ...validTask,
      status: 'completed',
      result: { answer: 'Artificial Intelligence' },
      model: 'gpt-4',
      error: undefined,
      started_at: new Date().toISOString(),
      finished_at: new Date().toISOString(),
    };
    expect(withOptional.result).toBeObject();
    expect(withOptional.model).toBeString();
    expect(withOptional.error).toBeUndefined();
    expect(withOptional.started_at).toBeString();
    expect(withOptional.finished_at).toBeString();
  });
});

describe('Prompt', () => {
  const validPrompt: Prompt = {
    id: 'prompt_1',
    key: 'welcome',
    content: 'Welcome to the system!',
    category: 'system',
    version: 1,
    is_active: true,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  test.each([
    ['system'],
    ['task'],
    ['tool'],
  ] as const)('should accept category "%s"', (category) => {
    const prompt: Prompt = { ...validPrompt, category };
    expect(prompt.category).toBe(category);
  });

  test('should create a valid Prompt object', () => {
    expect(validPrompt.id).toBeString();
    expect(validPrompt.key).toBeString();
    expect(validPrompt.content).toBeString();
    expect(validPrompt.version).toBeNumber();
    expect(validPrompt.is_active).toBeBoolean();
    expect(validPrompt.created_at).toBeString();
    expect(validPrompt.updated_at).toBeString();
  });

  test('should allow optional description and metadata', () => {
    const withOptional: Prompt = {
      ...validPrompt,
      description: 'A welcome prompt',
      metadata: { author: 'admin' },
    };
    expect(withOptional.description).toBeString();
    expect(withOptional.metadata).toBeObject();
  });
});

describe('WorkflowState', () => {
  const validState: WorkflowState = {
    mode: 'default',
    planSummary: null,
    isImplementReady: false,
  };

  test.each([
    ['default'],
    ['planning'],
    ['build'],
  ] as const)('should accept mode "%s"', (mode) => {
    const state: WorkflowState = { ...validState, mode };
    expect(state.mode).toBe(mode);
  });

  test('should create a valid WorkflowState object', () => {
    expect(validState.mode).toBe('default');
    expect(validState.planSummary).toBeNull();
    expect(validState.isImplementReady).toBe(false);
  });

  test('should accept a PlanSummary object', () => {
    const plan: PlanSummary = {
      requirement: 'Implement feature X',
      technicalPlan: 'Use React and TypeScript',
      implementationSteps: ['Step 1', 'Step 2'],
      confirmedAt: new Date().toISOString(),
    };
    const withPlan: WorkflowState = { ...validState, planSummary: plan, isImplementReady: true };
    expect(withPlan.planSummary).toBeDefined();
    expect(withPlan.isImplementReady).toBe(true);
  });
});