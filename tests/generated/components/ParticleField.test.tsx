// AUTO-GENERATED BY generate-tests.ts
// Source: src/components/ParticleField.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { render, screen } from '@testing-library/react';
import { vi } from 'vitest';
import ParticleField from '../../../src/components/ParticleField';

describe('ParticleField component', () => {
  // Helper to mock Math.random sequentially
  const mockMathRandom = (values: number[]) => {
    const iterator = values[Symbol.iterator]();
    return vi.spyOn(Math, 'random').mockImplementation(() => {
      const result = iterator.next();
      return result.done ? 0 : result.value;
    });
  };

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('renders default number of particles (count = 114)', () => {
    render(<ParticleField />);
    const spans = screen.getAllByRole('presentation');
    expect(spans).toHaveLength(114);
  });

  it('renders custom count of particles', () => {
    render(<ParticleField count={5} />);
    const spans = screen.getAllByRole('presentation');
    expect(spans).toHaveLength(5);
  });

  it('generates deterministic particle properties when Math.random is mocked', () => {
    // Mock Math.random to return 0.5 for all calls
    mockMathRandom([0.5, 0.5, 0.5, 0.5, 0.5]);

    render(<ParticleField count={1} />);
    const span = screen.getByRole('presentation');

    // Expected values based on the deterministic random outputs
    const expectedRadius = 500 + 0.5 * 260; // 630
    const expectedAngle = 0.5 * Math.PI * 2; // π
    const expectedStartX = Math.cos(expectedAngle) * expectedRadius; // -630
    const expectedStartY = Math.sin(expectedAngle) * (expectedRadius - 100); // 0
    const expectedSize = 10 + 0.5 * 18; // 19
    const expectedDelay = 0.5 * 0.6; // 0.3
    const expectedColor = 'rgba(147,197,253,0.35)'; // BLUE_PALETTE[2]

    // Check style attributes
    expect(span).toHaveStyle(`width: ${expectedSize}px`);
    expect(span).toHaveStyle(`height: ${expectedSize}px`);
    expect(span).toHaveStyle(`backgroundColor: ${expectedColor}`);
    expect(span).toHaveStyle(`boxShadow: 0 0 ${expectedSize * 1.5}px ${expectedColor}`);

    // Check initial animation props via data attributes (framer-motion adds them)
    const initial = span.getAttribute('data-initial');
    const animate = span.getAttribute('data-animate');
    const transition = span.getAttribute('data-transition');

    expect(initial).toContain(`x: ${expectedStartX}`);
    expect(initial).toContain(`y: ${expectedStartY}`);
    expect(animate).toContain(`x: [${expectedStartX}, ${expectedStartX * 0.15}]`);
    expect(animate).toContain(`y: [${expectedStartY}, ${expectedStartY * 0.15}]`);
    expect(transition).toContain(`delay: ${expectedDelay}`);
  });

  it('uses fallback color prop when BLUE_PALETTE selection is undefined', () => {
    // Mock Math.random to produce undefined color selection (index = 4)
    mockMathRandom([0, 0, 0, 0, 1]);

    const fallbackColor = 'rgba(255,0,0,0.5)';
    render(<ParticleField count={1} color={fallbackColor} />);
    const span = screen.getByRole('presentation');

    // Since BLUE_PALETTE[Math.floor(Math.random() * 4)] would be undefined, fallback should be used
    expect(span).toHaveStyle(`backgroundColor: ${fallbackColor}`);
  });

  it('container has correct className', () => {
    render(<ParticleField />);
    const container = screen.getByTestId('particle-field-container');
    expect(container).toHaveClass('fixed inset-0 overflow-hidden pointer-events-none');
  });
});