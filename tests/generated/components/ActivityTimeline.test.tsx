// AUTO-GENERATED BY generate-tests.ts
// Source: src/components/ActivityTimeline.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import ActivityTimeline from '../../../src/components/ActivityTimeline';

// Mock the useTimelineEvents hook
vi.mock('../../../src/realtime', () => ({
  useTimelineEvents: vi.fn(),
}));

import { useTimelineEvents } from '../../../src/realtime';

type MockEvent = {
  id: string;
  timestamp: string;
  type: string;
  payload: any;
};

type MockPhase = {
  id: string;
  timestamp: string;
  type: 'agent_phase';
  payload: { phase: string; action: 'enter' | 'exit'; summary?: string };
};

type MockRepair = {
  id: string;
  timestamp: string;
  type: 'self_repair';
  payload: { attemptNumber: number; maxAttempts: number; result: 'success' | 'failed' | 'pending'; trigger: string; errorMessage?: string };
};

type MockError = {
  id: string;
  timestamp: string;
  type: 'error';
  payload: { errorType: string; message: string };
};

describe('ActivityTimeline', () => {
  const defaultProps = {
    projectId: 'proj-1',
    taskId: 'task-1',
    maxEvents: 100,
    onFileSelect: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('returns null when there are no events and no current phase', () => {
    (useTimelineEvents as vi.Mock).mockReturnValue({
      events: [],
      phases: [],
      tools: [],
      files: [],
      repairs: [],
      errors: [],
      currentPhase: undefined,
      isConnected: true,
    });

    const { container } = render(<ActivityTimeline {...defaultProps} />);
    expect(container.firstChild).toBeNull();
  });

  it('renders header with action count and phase label', () => {
    const tools: MockEvent[] = [
      {
        id: 'tool-1',
        timestamp: new Date(Date.now() - 1000).toISOString(),
        type: 'tool_call',
        payload: { toolName: 'list_files', argsSummary: '/src', success: true },
      },
    ];
    const files: MockEvent[] = [
      {
        id: 'file-1',
        timestamp: new Date(Date.now() - 500).toISOString(),
        type: 'file_update',
        payload: { op: 'create', path: '/src/index.ts' },
      },
    ];
    const phases: MockPhase[] = [
      {
        id: 'phase-1',
        timestamp: new Date(Date.now() - 2000).toISOString(),
        type: 'agent_phase',
        payload: { phase: 'planner', action: 'enter', summary: 'Planning' },
      },
    ];

    (useTimelineEvents as vi.Mock).mockReturnValue({
      events: [...tools, ...files],
      phases,
      tools,
      files,
      repairs: [],
      errors: [],
      currentPhase: 'planner',
      isConnected: true,
    });

    render(<ActivityTimeline {...defaultProps} />);

    const button = screen.getByRole('button');
    expect(button).toHaveTextContent('2 actions taken');
    expect(button).toHaveTextContent('规划中');
  });

  it('toggles expand/collapse state on header click', async () => {
    const tools: MockEvent[] = [
      {
        id: 'tool-1',
        timestamp: new Date().toISOString(),
        type: 'tool_call',
        payload: { toolName: 'search_files', argsSummary: '', success: true },
      },
    ];

    (useTimelineEvents as vi.Mock).mockReturnValue({
      events: tools,
      phases: [],
      tools,
      files: [],
      repairs: [],
      errors: [],
      currentPhase: undefined,
      isConnected: true,
    });

    render(<ActivityTimeline {...defaultProps} />);

    const header = screen.getByRole('button');
    // Details should be visible initially
    expect(screen.getByText('Searched')).toBeInTheDocument();

    // Collapse
    fireEvent.click(header);
    expect(screen.queryByText('Searched')).toBeNull();

    // Expand again
    fireEvent.click(header);
    expect(screen.getByText('Searched')).toBeInTheDocument();
  });

  it('calls onFileSelect when file button is clicked', () => {
    const files: MockEvent[] = [
      {
        id: 'file-1',
        timestamp: new Date().toISOString(),
        type: 'file_update',
        payload: { op: 'delete', path: '/src/old.ts' },
      },
    ];

    (useTimelineEvents as vi.Mock).mockReturnValue({
      events: files,
      phases: [],
      tools: [],
      files,
      repairs: [],
      errors: [],
      currentPhase: undefined,
      isConnected: true,
    });

    render(<ActivityTimeline {...defaultProps} />);

    const button = screen.getByRole('button', { name: '/src/old.ts' });
    fireEvent.click(button);
    expect(defaultProps.onFileSelect).toHaveBeenCalledWith('/src/old.ts');
  });

  it('renders plan items with correct status icons', () => {
    const phases: MockPhase[] = [
      {
        id: 'phase-1',
        timestamp: new Date(Date.now() - 2000).toISOString(),
        type: 'agent_phase',
        payload: { phase: 'coder', action: 'enter', summary: 'Coding' },
      },
      {
        id: 'phase-2',
        timestamp: new Date(Date.now() - 1000).toISOString(),
        type: 'agent_phase',
        payload: { phase: 'coder', action: 'exit' },
      },
    ];
    const tools: MockEvent[] = [
      {
        id: 'tool-1',
        timestamp: new Date(Date.now() - 1500).toISOString(),
        type: 'tool_call',
        payload: { toolName: 'write_file', argsSummary: '/src/app.ts', success: true },
      },
    ];

    (useTimelineEvents as vi.Mock).mockReturnValue({
      events: tools,
      phases,
      tools,
      files: [],
      repairs: [],
      errors: [],
      currentPhase: 'coder',
      isConnected: true,
    });

    render(<ActivityTimeline {...defaultProps} />);

    // Plan item text
    expect(screen.getByText('Coding')).toBeInTheDocument();

    // Action inside plan
    expect(screen.getByText('Edited')).toBeInTheDocument();
  });

  it('renders actions list when there are no plan items', () => {
    const tools: MockEvent[] = [
      {
        id: 'tool-1',
        timestamp: new Date().toISOString(),
        type: 'tool_call',
        payload: { toolName: 'search_files', argsSummary: '', success: true },
      },
    ];

    (useTimelineEvents as vi.Mock).mockReturnValue({
      events: tools,
      phases: [],
      tools,
      files: [],
      repairs: [],
      errors: [],
      currentPhase: undefined,
      isConnected: true,
    });

    render(<ActivityTimeline {...defaultProps} />);

    expect(screen.getByText('Searched')).toBeInTheDocument();
  });

  it('renders repair and error items', () => {
    const repairs: MockRepair[] = [
      {
        id: 'repair-1',
        timestamp: new Date().toISOString(),
        type: 'self_repair',
        payload: { attemptNumber: 1, maxAttempts: 3, result: 'failed', trigger: 'auto', errorMessage: 'Something went wrong' },
      },
    ];
    const errors: MockError[] = [
      {
        id: 'error-1',
        timestamp: new Date().toISOString(),
        type: 'error',
        payload: { errorType: 'RuntimeError', message: 'Unexpected token' },
      },
    ];

    (useTimelineEvents as vi.Mock).mockReturnValue({
      events: [],
      phases: [],
      tools: [],
      files: [],
      repairs,
      errors,
      currentPhase: undefined,
      isConnected: true,
    });

    render(<ActivityTimeline {...defaultProps} />);

    expect(screen.getByText('自修复 1/3')).toBeInTheDocument();
    expect(screen.getByText('Something went wrong')).toBeInTheDocument();
    expect(screen.getByText('RuntimeError')).toBeInTheDocument();
    expect(screen.getByText('Unexpected token')).toBeInTheDocument();
  });

  // Parameterized test for different tool calls
  const toolCallCases = [
    ['list_files', 'Listed', '/src'],
    ['read_file', 'Read', '/src/index.ts'],
    ['write_file', 'Edited', '/src/app.ts'],
    ['delete_file', 'Deleted', '/src/old.ts'],
    ['move_file', 'Moved', '/src/moved.ts'],
    ['search_files', 'Searched', ''],
    ['generate_image', 'Generated', '/images/img.png'],
  ];

  test.each(toolCallCases)(
    'renders %s tool call with label %s and file path %s',
    (toolName, label, filePath) => {
      const tools: MockEvent[] = [
        {
          id: `tool-${toolName}`,
          timestamp: new Date().toISOString(),
          type: 'tool_call',
          payload: { toolName, argsSummary: filePath, success: true },
        },
      ];

      (useTimelineEvents as vi.Mock).mockReturnValue({
        events: tools,
        phases: [],
        tools,
        files: [],
        repairs: [],
        errors: [],
        currentPhase: undefined,
        isConnected: true,
      });

      render(<ActivityTimeline {...defaultProps} />);

      expect(screen.getByText(label)).toBeInTheDocument();
      if (filePath) {
        expect(screen.getByText(filePath)).toBeInTheDocument();
      }
    }
  );
});