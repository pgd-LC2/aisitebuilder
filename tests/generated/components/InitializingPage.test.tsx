// AUTO-GENERATED BY generate-tests.ts
// Source: src/components/InitializingPage.tsx
// DO NOT EDIT MANUALLY - ä¿®æ”¹å°†åœ¨ä¸‹æ¬¡ç”Ÿæˆæ—¶è¢«è¦†ç›–

import { render, screen, fireEvent } from '@testing-library/react';
import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
import InitializingPage from '../../../src/components/InitializingPage';
import '@testing-library/jest-dom';

describe('InitializingPage', () => {
  const projectTitle = 'Test Project';

  beforeEach(() => {
    // Mock Math.random to make shuffling deterministic
    vi.spyOn(Math, 'random').mockImplementation(() => 0.5);
    // Use fake timers for setTimeout
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.restoreAllMocks();
    vi.clearAllTimers();
  });

  it('renders header with project title', () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    expect(screen.getByText(projectTitle)).toBeInTheDocument();
  });

  it('initially shows 0 moves and 0 matched pairs', () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    expect(screen.getByText(/æ­¥æ•°:/)).toHaveTextContent('æ­¥æ•°: 0');
    expect(screen.getByText(/é…å¯¹:/)).toHaveTextContent('é…å¯¹: 0/8');
  });

  it('renders 16 card buttons initially with placeholder ?', () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    const cardButtons = screen.getAllByRole('button', { name: '?' });
    expect(cardButtons).toHaveLength(16);
  });

  it('flips a card on click and shows its icon', async () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    const firstButton = screen.getAllByRole('button', { name: '?' })[0];
    fireEvent.click(firstButton);
    // After click, the button should display its icon
    await screen.findByText(/./, { selector: 'button' });
    const iconButton = screen.getByRole('button', { name: /./ });
    expect(iconButton).not.toHaveTextContent('?');
  });

  it('does not allow clicking a second card when two cards are already flipped', () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    const buttons = screen.getAllByRole('button', { name: '?' });
    fireEvent.click(buttons[0]);
    fireEvent.click(buttons[1]);
    // Second click should be ignored because two cards are flipped
    fireEvent.click(buttons[2]);
    // The third card should still show '?'
    expect(buttons[2]).toHaveTextContent('?');
  });

  it('matches two cards with same icon and increments matchedPairs', async () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    const buttons = screen.getAllByRole('button', { name: '?' });

    // Click first card
    fireEvent.click(buttons[0]);
    const firstIcon = (await screen.findByRole('button', { name: /./ })).textContent!;

    // Find another card with the same icon
    const matchingButton = buttons.find(btn => btn.textContent === firstIcon);
    expect(matchingButton).toBeDefined();
    fireEvent.click(matchingButton!);

    // Moves should increment after second click
    expect(screen.getByText(/æ­¥æ•°:/)).toHaveTextContent('æ­¥æ•°: 1');

    // Run timers to trigger match handling
    vi.runAllTimers();

    // Both cards should be disabled and have opacity-60
    expect(matchingButton!).toBeDisabled();
    expect(matchingButton!).toHaveStyle('opacity: 0.6');
    expect(buttons[0]).toBeDisabled();

    // matchedPairs should increment
    expect(screen.getByText(/é…å¯¹:/)).toHaveTextContent('é…å¯¹: 1/8');
  });

  it('unflips two non-matching cards after delay', async () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    const buttons = screen.getAllByRole('button', { name: '?' });

    // Click first card
    fireEvent.click(buttons[0]);
    const firstIcon = (await screen.findByRole('button', { name: /./ })).textContent!;

    // Find a card with a different icon
    const nonMatchingButton = buttons.find(btn => btn.textContent !== firstIcon && btn.textContent === '?');
    expect(nonMatchingButton).toBeDefined();
    fireEvent.click(nonMatchingButton!);

    // Run timers to trigger unflip handling (1000ms)
    vi.runAllTimers();

    // Both cards should be back to placeholder '?'
    expect(buttons[0]).toHaveTextContent('?');
    expect(nonMatchingButton!).toHaveTextContent('?');
  });

  it('prevents clicking a matched card', async () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    const buttons = screen.getAllByRole('button', { name: '?' });

    // Match a pair first
    fireEvent.click(buttons[0]);
    const firstIcon = (await screen.findByRole('button', { name: /./ })).textContent!;
    const matchingButton = buttons.find(btn => btn.textContent === firstIcon && btn.textContent === '?');
    fireEvent.click(matchingButton!);
    vi.runAllTimers();

    // Now click the matched card again
    fireEvent.click(matchingButton!);
    // It should be disabled, so no further action
    expect(matchingButton!).toBeDisabled();
  });

  it('shows completion message after all pairs matched and allows reset', async () => {
    render(<InitializingPage projectTitle={projectTitle} />);
    const buttons = screen.getAllByRole('button', { name: '?' });

    // Helper to match all pairs
    const matchAllPairs = async () => {
      for (let i = 0; i < buttons.length; i += 2) {
        const btn1 = buttons[i];
        const btn2 = buttons[i + 1];
        const icon1 = (await screen.findByRole('button', { name: /./ })).textContent!;
        // Find a matching icon among remaining buttons
        const matchingBtn = buttons.find(btn => btn.textContent === icon1 && btn !== btn1);
        if (!matchingBtn) continue;
        fireEvent.click(btn1);
        fireEvent.click(matchingBtn);
        vi.runAllTimers();
      }
    };

    // Since icons are duplicated, we can just click each card twice to match all
    // For simplicity, we simulate matching by clicking each card and then its duplicate
    // This test focuses on the completion state, not the exact matching logic.
    // We'll just manually set the state via the component's internal logic by triggering clicks.
    // For brevity, we will assume the component will eventually reach matchedPairs === 8.
    // We'll simulate this by manually setting the state using a custom render wrapper.
    // However, since we cannot access internal state directly, we will skip exhaustive matching
    // and instead trigger the completion UI by manually setting matchedPairs via a mocked function.
    // To keep the test realistic, we will match pairs until the UI shows the completion message.

    // Match pairs until completion message appears
    while (!screen.queryByText(/ğŸ‰ æ­å–œå®Œæˆï¼/)) {
      // Find two cards with same icon
      const visibleCards = screen.getAllByRole('button', { name: /./ });
      if (visibleCards.length < 2) break;
      const firstIcon = visibleCards[0].textContent!;
      const secondCard = visibleCards.find(btn => btn.textContent === firstIcon && btn !== visibleCards[0]);
      if (!secondCard) {
        // Flip a card to reveal its icon
        const hiddenButtons = screen.getAllByRole('button', { name: '?' });
        fireEvent.click(hiddenButtons[0]);
        continue;
      }
      fireEvent.click(visibleCards[0]);
      fireEvent.click(secondCard);
      vi.runAllTimers();
    }

    const completionMessage = screen.getByText(/ğŸ‰ æ­å–œå®Œæˆï¼/);
    expect(completionMessage).toBeInTheDocument();

    const resetButton = screen.getByRole('button', { name: 'å†ç©ä¸€æ¬¡' });
    expect(resetButton).toBeInTheDocument();

    // Click reset
    fireEvent.click(resetButton);
    vi.runAllTimers();

    // After reset, moves and matchedPairs should be 0
    expect(screen.getByText(/æ­¥æ•°:/)).toHaveTextContent('æ­¥æ•°: 0');
    expect(screen.getByText(/é…å¯¹:/)).toHaveTextContent('é…å¯¹: 0/8');

    // All cards should be back to placeholder '?'
    const resetButtons = screen.getAllByRole('button', { name: '?' });
    expect(resetButtons).toHaveLength(16);
  });
});