// AUTO-GENERATED BY generate-tests.ts
// Source: src/components/VersionManager.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import VersionManager from '../../../src/components/VersionManager';
import '@testing-library/jest-dom';

// Mock external dependencies
vi.mock('../../../src/components/CodeViewer', () => ({
  default: () => <div data-testid="code-viewer">Code Viewer</div>
}));

vi.mock('../../../src/services/versionService', () => ({
  versionService: {
    getVersionsByProjectId: vi.fn(),
    createVersion: vi.fn(),
    deleteVersion: vi.fn()
  }
}));

vi.mock('../../../src/services/fileService', () => ({
  fileService: {
    getFilesByProject: vi.fn(),
    formatFileSize: vi.fn()
  }
}));

const { versionService } = await import('../../../src/services/versionService');
const { fileService } = await import('../../../src/services/fileService');

// Common mock data
const mockVersions = [
  {
    id: 'v1',
    version_number: 1,
    created_at: '2024-01-01T12:00:00Z',
    code_snapshot: { 'src/index.tsx': 'console.log("v1");' },
    preview_url: ''
  },
  {
    id: 'v2',
    version_number: 2,
    created_at: '2024-02-01T12:00:00Z',
    code_snapshot: { 'src/index.tsx': 'console.log("v2");' },
    preview_url: ''
  }
];

const mockFiles = [
  {
    file_name: 'index.tsx',
    file_path: 'src/index.tsx',
    file_size: 123,
    mime_type: 'text/typescript',
    file_category: 'code'
  },
  {
    file_name: 'utils.ts',
    file_path: 'src/utils.ts',
    file_size: 45,
    mime_type: 'text/typescript',
    file_category: 'code'
  },
  {
    file_name: 'README.md',
    file_path: 'README.md',
    file_size: 30,
    mime_type: 'text/markdown',
    file_category: 'doc'
  }
];

const mockFormattedSize = '10 KB';

beforeEach(() => {
  vi.clearAllMocks();
  vi.spyOn(window, 'prompt').mockImplementation(() => 'New version description');
  vi.spyOn(window, 'confirm').mockImplementation(() => true);
  vi.spyOn(window, 'alert').mockImplementation(() => {});
  fileService.formatFileSize.mockReturnValue(mockFormattedSize);
});

describe('VersionManager', () => {
  test('renders loading spinner and then version list', async () => {
    versionService.getVersionsByProjectId.mockResolvedValue({ data: mockVersions, error: null });

    render(<VersionManager projectId="proj1" onClose={() => {}} />);

    // Loading spinner should be visible
    expect(screen.getByText('加载版本历史...')).toBeInTheDocument();

    // After loading, spinner disappears and versions appear
    await waitFor(() => {
      expect(screen.queryByText('加载版本历史...')).not.toBeInTheDocument();
    });

    // Verify version items
    mockVersions.forEach(v => {
      expect(screen.getByText(`v${v.version_number}`)).toBeInTheDocument();
    });
  });

  test('selects a version and loads its file tree', async () => {
    versionService.getVersionsByProjectId.mockResolvedValue({ data: mockVersions, error: null });
    fileService.getFilesByProject.mockResolvedValue({ data: mockFiles });

    render(<VersionManager projectId="proj1" onClose={() => {}} />);

    // Wait for versions to load
    await waitFor(() => expect(screen.getByText('v1')).toBeInTheDocument());

    // Click on second version
    fireEvent.click(screen.getByText('v2'));

    // Verify that the header shows selected version
    await waitFor(() => expect(screen.getByText('版本 v2')).toBeInTheDocument());

    // Verify that files are loaded
    await waitFor(() => {
      mockFiles.forEach(f => {
        expect(screen.getByText(f.file_name)).toBeInTheDocument();
      });
    });
  });

  test('navigates folders and selects a file', async () => {
    versionService.getVersionsByProjectId.mockResolvedValue({ data: mockVersions, error: null });
    // Files with nested folders
    const nestedFiles = [
      {
        file_name: 'index.tsx',
        file_path: 'src/index.tsx',
        file_size: 123,
        mime_type: 'text/typescript',
        file_category: 'code'
      },
      {
        file_name: 'utils.ts',
        file_path: 'src/utils.ts',
        file_size: 45,
        mime_type: 'text/typescript',
        file_category: 'code'
      },
      {
        file_name: 'README.md',
        file_path: 'README.md',
        file_size: 30,
        mime_type: 'text/markdown',
        file_category: 'doc'
      }
    ];
    fileService.getFilesByProject.mockResolvedValue({ data: nestedFiles });

    render(<VersionManager projectId="proj1" onClose={() => {}} />);

    await waitFor(() => expect(screen.getByText('v1')).toBeInTheDocument());

    // Click on folder 'src'
    fireEvent.click(screen.getByText('src'));

    // Verify that root path button appears
    expect(screen.getByText('根目录')).toBeInTheDocument();

    // Click on file 'index.tsx'
    fireEvent.click(screen.getByText('index.tsx'));

    // Verify file details panel
    expect(screen.getByText('index.tsx')).toBeInTheDocument();
    expect(screen.getByText('console.log("v1");')).not.toBeInTheDocument(); // code not shown yet
    expect(screen.getByText(mockFormattedSize)).toBeInTheDocument();
  });

  test('shows CodeViewer when clicking view code button', async () => {
    versionService.getVersionsByProjectId.mockResolvedValue({ data: mockVersions, error: null });
    fileService.getFilesByProject.mockResolvedValue({ data: mockFiles });

    render(<VersionManager projectId="proj1" onClose={() => {}} />);

    await waitFor(() => expect(screen.getByText('v1')).toBeInTheDocument());

    // Click on file 'index.tsx'
    fireEvent.click(screen.getByText('index.tsx'));

    // Click on '查看代码' button
    fireEvent.click(screen.getByText('查看代码'));

    // Verify CodeViewer rendered
    expect(screen.getByTestId('code-viewer')).toBeInTheDocument();
  });

  test('creates a new version via prompt', async () => {
    versionService.getVersionsByProjectId.mockResolvedValue({ data: mockVersions, error: null });
    versionService.createVersion.mockResolvedValue({
      data: {
        id: 'v3',
        version_number: 3,
        created_at: '2024-03-01T12:00:00Z',
        code_snapshot: { 'src/index.tsx': 'console.log("v3");' },
        preview_url: ''
      },
      error: null
    });

    render(<VersionManager projectId="proj1" onClose={() => {}} />);

    await waitFor(() => expect(screen.getByText('v1')).toBeInTheDocument());

    // Click '创建新版本' button
    fireEvent.click(screen.getByText('创建新版本'));

    // Verify createVersion called with correct args
    await waitFor(() => {
      expect(versionService.createVersion).toHaveBeenCalledWith(
        'proj1',
        3,
        mockVersions[0].code_snapshot,
        mockVersions[0].preview_url,
        mockVersions[0].id
      );
    });

    // Verify alert called
    expect(window.alert).toHaveBeenCalledWith('成功创建版本 v3');
  });

  test('restores a version after confirmation', async () => {
    versionService.getVersionsByProjectId.mockResolvedValue({ data: mockVersions, error: null });
    versionService.createVersion.mockResolvedValue({
      data: {
        id: 'v4',
        version_number: 4,
        created_at: '2024-04-01T12:00:00Z',
        code_snapshot: { 'src/index.tsx': 'console.log("v4");' },
        preview_url: ''
      },
      error: null
    });

    const onVersionRestore = vi.fn();

    render(
      <VersionManager
        projectId="proj1"
        onClose={() => {}}
        onVersionRestore={onVersionRestore}
      />
    );

    await waitFor(() => expect(screen.getByText('v1')).toBeInTheDocument());

    // Click '回退到此版本' button on first version
    fireEvent.click(screen.getByText('回退到此版本'));

    // Verify createVersion called
    await waitFor(() => {
      expect(versionService.createVersion).toHaveBeenCalledWith(
        'proj1',
        3,
        mockVersions[0].code_snapshot,
        mockVersions[0].preview_url,
        mockVersions[0].id
      );
    });

    // Verify alert called
    expect(window.alert).toHaveBeenCalledWith('成功回退到版本 v1， 新版本号为 v3');

    // Verify onVersionRestore called with new version
    expect(onVersionRestore).toHaveBeenCalledWith(expect.objectContaining({ id: 'v4' }));
  });

  test('deletes a version after confirmation', async () => {
    versionService.getVersionsByProjectId.mockResolvedValue({ data: mockVersions, error: null });
    versionService.deleteVersion.mockResolvedValue({ error: null });

    render(<VersionManager projectId="proj1" onClose={() => {}} />);

    await waitFor(() => expect(screen.getByText('v1')).toBeInTheDocument());

    // Click '删除版本' button on second version (since length > 1)
    fireEvent.click(screen.getByText('删除版本'));

    // Verify deleteVersion called
    await waitFor(() => {
      expect(versionService.deleteVersion).toHaveBeenCalledWith('v2');
    });

    // Verify alert called
    expect(window.alert).toHaveBeenCalledWith('版本已删除');
  });

  test('does not render delete button when only one version exists', async () => {
    versionService.getVersionsByProjectId.mockResolvedValue({ data: [mockVersions[0]], error: null });

    render(<VersionManager projectId="proj1" onClose={() => {}} />);

    await waitFor(() => expect(screen.getByText('v1')).toBeInTheDocument());

    // Delete button should not be present
    expect(screen.queryByText('删除版本')).not.toBeInTheDocument();
  });
});