// AUTO-GENERATED BY generate-tests.ts
// Source: src/components/BuildLogPanel.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import BuildLogPanel from '../../../src/components/BuildLogPanel';
import { vi } from 'vitest';

// Mock the realtime hook
const mockUseBuildLogs = vi.fn();
vi.mock('../../../src/realtime', () => ({
  useBuildLogs: mockUseBuildLogs,
}));

// Helper to render component with mocked hook
const renderComponent = (logs: any[] = [], loading = false) => {
  mockUseBuildLogs.mockReturnValue({ logs, isLoading: loading });
  return render(<BuildLogPanel projectId="123" />);
};

describe('BuildLogPanel', () => {
  const mockLogs = [
    {
      id: '1',
      project_id: '123',
      log_type: 'info',
      message: '任务开始',
      created_at: '2024-01-01T12:00:00Z',
    },
    {
      id: '2',
      project_id: '123',
      log_type: 'success',
      message: '任务完成',
      created_at: '2024-01-01T12:05:00Z',
    },
    {
      id: '3',
      project_id: '123',
      log_type: 'error',
      message: '工具执行失败',
      created_at: '2024-01-01T12:10:00Z',
    },
    // This log should be filtered out (not a task lifecycle event)
    {
      id: '4',
      project_id: '123',
      log_type: 'info',
      message: '文件操作详情',
      created_at: '2024-01-01T12:15:00Z',
    },
  ];

  afterEach(() => {
    vi.clearAllMocks();
  });

  test('renders the toggle button with title', () => {
    renderComponent();
    const button = screen.getByRole('button', { name: /构建日志/i });
    expect(button).toBeInTheDocument();
  });

  test('shows loading state when isLoading is true', () => {
    renderComponent([], true);
    const loadingDiv = screen.getByText(/加载中…/i);
    expect(loadingDiv).toBeInTheDocument();
  });

  test('shows "暂无日志" when there are no task lifecycle logs', () => {
    // All logs are filtered out
    const filteredLogs = mockLogs.filter((log) => log.id === '4');
    renderComponent(filteredLogs);
    const toggleButton = screen.getByRole('button');
    fireEvent.click(toggleButton);
    const emptyDiv = screen.getByText(/暂无日志/i);
    expect(emptyDiv).toBeInTheDocument();
  });

  test('renders log count badge and list when logs are present', () => {
    // Only first three logs should pass the filter
    renderComponent(mockLogs);
    const toggleButton = screen.getByRole('button');
    fireEvent.click(toggleButton);
    const badge = screen.getByText('3');
    expect(badge).toBeInTheDocument();

    // Verify each log entry
    const logItems = screen.getAllByRole('listitem') || screen.getAllByText(/任务|完成|失败|工具执行失败/i);
    expect(logItems.length).toBe(3);

    // Check content of first log
    expect(screen.getByText(/任务开始/i)).toBeInTheDocument();
    expect(screen.getByText(/INFO/i)).toBeInTheDocument();
    expect(screen.getByText(/12:00:00/i)).toBeInTheDocument();

    // Check that filtered log is not rendered
    expect(screen.queryByText(/文件操作详情/i)).toBeNull();
  });

  test('expands and collapses the log panel on button click', () => {
    renderComponent(mockLogs);
    const toggleButton = screen.getByRole('button');
    // Initially collapsed
    expect(screen.queryByText(/任务开始/i)).toBeNull();

    // Expand
    fireEvent.click(toggleButton);
    expect(screen.getByText(/任务开始/i)).toBeInTheDocument();

    // Collapse
    fireEvent.click(toggleButton);
    await waitFor(() => {
      expect(screen.queryByText(/任务开始/i)).toBeNull();
    });
  });

  test('export button triggers download with correct filename', () => {
    renderComponent(mockLogs);
    const toggleButton = screen.getByRole('button');
    fireEvent.click(toggleButton);

    const exportBtn = screen.getByTitle(/导出日志/i);
    expect(exportBtn).toBeInTheDocument();

    // Mock DOM methods
    const mockA = {
      href: '',
      download: '',
      click: vi.fn(),
    };
    const createElementMock = vi.spyOn(document, 'createElement').mockReturnValue(mockA as any);
    const appendChildMock = vi.spyOn(document.body, 'appendChild').mockImplementation(() => {});
    const removeChildMock = vi.spyOn(document.body, 'removeChild').mockImplementation(() => {});
    const revokeMock = vi.spyOn(URL, 'revokeObjectURL').mockImplementation(() => {});

    fireEvent.click(exportBtn);

    expect(createElementMock).toHaveBeenCalledWith('a');
    expect(mockA.click).toHaveBeenCalled();
    expect(mockA.download).toBe('build-logs-123.txt');
    expect(revokeMock).toHaveBeenCalled();

    // Restore mocks
    createElementMock.mockRestore();
    appendChildMock.mockRestore();
    removeChildMock.mockRestore();
    revokeMock.mockRestore();
  });

  test('renders correct icons and colors based on log_type', () => {
    renderComponent(mockLogs);
    const toggleButton = screen.getByRole('button');
    fireEvent.click(toggleButton);

    // Info log
    const infoIcon = screen.getByTestId('Info'); // lucide icons have data-testid equal to component name
    expect(infoIcon).toBeInTheDocument();

    // Success log
    const successIcon = screen.getByTestId('CheckCircle');
    expect(successIcon).toBeInTheDocument();

    // Error log
    const errorIcon = screen.getByTestId('AlertCircle');
    expect(errorIcon).toBeInTheDocument();

    // Verify color classes
    const infoBadge = screen.getByText(/INFO/i).parentElement;
    expect(infoBadge).toHaveClass('bg-blue-100', 'text-blue-700');

    const successBadge = screen.getByText(/SUCCESS/i).parentElement;
    expect(successBadge).toHaveClass('bg-green-100', 'text-green-700');

    const errorBadge = screen.getByText(/ERROR/i).parentElement;
    expect(errorBadge).toHaveClass('bg-red-100', 'text-red-700');
  });

  test('formatTime outputs correct time string for a log entry', () => {
    renderComponent(mockLogs);
    const toggleButton = screen.getByRole('button');
    fireEvent.click(toggleButton);

    // The time for the first log is 12:00:00 (UTC). In zh-CN locale, it should show in local time.
    // Since the test environment may be different, we just check that a time string appears.
    const timeElement = screen.getByText(/\d{2}:\d{2}:\d{2}/i);
    expect(timeElement).toBeInTheDocument();
  });
});