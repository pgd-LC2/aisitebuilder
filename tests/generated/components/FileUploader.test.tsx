// AUTO-GENERATED BY generate-tests.ts
// Source: src/components/FileUploader.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import FileUploader from '../../../src/components/FileUploader';
import { FileUploadProgress } from '../../../src/types/project';

describe('FileUploader component', () => {
  const defaultProps = {
    onFilesSelected: vi.fn(),
    accept: 'image/*',
    maxSize: 5 * 1024 * 1024, // 5 MB
    multiple: true,
    uploading: false,
    uploadProgress: [] as FileUploadProgress[]
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  test('renders upload area with correct text and icon', () => {
    render(<FileUploader {...defaultProps} />);
    expect(screen.getByText(/点击上传或拖拽文件到这里/i)).toBeInTheDocument();
    expect(screen.getByText(/单个文件最大 5.00 MB/i)).toBeInTheDocument();
    expect(screen.getByRole('img', { name: '' })).toBeInTheDocument(); // Upload icon
  });

  test('calls onFilesSelected when files are selected via input change', () => {
    const file = new File(['content'], 'test.png', { type: 'image/png', size: 1024 });
    render(<FileUploader {...defaultProps} />);
    const input = screen.getByRole('textbox', { name: '' }) as HTMLInputElement; // hidden input
    fireEvent.change(input, { target: { files: [file] } });
    expect(defaultProps.onFilesSelected).toHaveBeenCalledWith([file]);
    expect(screen.getByText('test.png')).toBeInTheDocument();
    expect(screen.getByText('1.00 KB')).toBeInTheDocument();
  });

  test.each([
    [{ size: 6 * 1024 * 1024 }, '文件 test.png 超过大小限制 5.00 MB'],
    [{ size: 4 * 1024 * 1024 }, null]
  ])('handles maxSize validation', (fileProps, expectedAlertMessage) => {
    const file = new File(['content'], 'test.png', { type: 'image/png', ...fileProps });
    const alertSpy = vi.spyOn(window, 'alert').mockImplementation(() => {});
    render(<FileUploader {...defaultProps} />);
    const input = screen.getByRole('textbox', { name: '' }) as HTMLInputElement;
    fireEvent.change(input, { target: { files: [file] } });
    if (expectedAlertMessage) {
      expect(alertSpy).toHaveBeenCalledWith(expectedAlertMessage);
      expect(defaultProps.onFilesSelected).not.toHaveBeenCalled();
    } else {
      expect(alertSpy).not.toHaveBeenCalled();
      expect(defaultProps.onFilesSelected).toHaveBeenCalledWith([file]);
    }
  });

  test('does not allow file selection when uploading flag is true', () => {
    const file = new File(['content'], 'test.png', { type: 'image/png', size: 1024 });
    render(<FileUploader {...defaultProps} uploading />);
    const input = screen.getByRole('textbox', { name: '' }) as HTMLInputElement;
    fireEvent.change(input, { target: { files: [file] } });
    expect(defaultProps.onFilesSelected).not.toHaveBeenCalled();
    expect(screen.queryByText('test.png')).not.toBeInTheDocument();
  });

  test('removes a selected file when delete button is clicked', () => {
    const file1 = new File(['c1'], 'file1.txt', { size: 500 });
    const file2 = new File(['c2'], 'file2.txt', { size: 800 });
    render(<FileUploader {...defaultProps} />);
    const input = screen.getByRole('textbox', { name: '' }) as HTMLInputElement;
    fireEvent.change(input, { target: { files: [file1, file2] } });
    expect(screen.getByText('file1.txt')).toBeInTheDocument();
    expect(screen.getByText('file2.txt')).toBeInTheDocument();
    const deleteButtons = screen.getAllByRole('button');
    fireEvent.click(deleteButtons[0]); // delete file1
    expect(screen.queryByText('file1.txt')).not.toBeInTheDocument();
    expect(screen.getByText('file2.txt')).toBeInTheDocument();
  });

  test.each([
    {
      status: { file: new File([], 'file.png'), progress: 50, status: 'uploading' },
      expectedProgress: 50
    },
    {
      status: { file: new File([], 'file.png'), status: 'success' },
      expectedSuccess: true
    },
    {
      status: { file: new File([], 'file.png'), status: 'error', error: '网络错误' },
      expectedError: '网络错误'
    }
  ])('renders file status correctly', async ({ status, expectedProgress, expectedSuccess, expectedError }) => {
    const file = new File(['content'], status.file.name, { size: 1024 });
    render(<FileUploader {...defaultProps} uploadProgress={[status]} />);
    const input = screen.getByRole('textbox', { name: '' }) as HTMLInputElement;
    fireEvent.change(input, { target: { files: [file] } });
    await waitFor(() => expect(screen.getByText(file.name)).toBeInTheDocument());
    if (expectedProgress !== undefined) {
      const progressBar = screen.getByRole('progressbar') as HTMLDivElement;
      expect(progressBar.style.width).toBe(`${expectedProgress}%`);
    }
    if (expectedSuccess) {
      expect(screen.getByTestId('checkcircle')).toBeInTheDocument();
    }
    if (expectedError) {
      expect(screen.getByText(expectedError)).toBeInTheDocument();
      expect(screen.getByTestId('alertcircle')).toBeInTheDocument();
    }
  });

  test('drag and drop files triggers handleFiles', () => {
    const file = new File(['content'], 'drag.png', { size: 1024 });
    render(<FileUploader {...defaultProps} />);
    const dropZone = screen.getByText(/点击上传或拖拽文件到这里/i);
    const dataTransfer = {
      files: [file],
      items: [],
      types: ['Files'],
      getData: vi.fn(),
      setData: vi.fn(),
      clearData: vi.fn()
    };
    fireEvent.drop(dropZone, { dataTransfer });
    expect(defaultProps.onFilesSelected).toHaveBeenCalledWith([file]);
    expect(screen.getByText('drag.png')).toBeInTheDocument();
  });

  test('drag events set isDragging state correctly', () => {
    render(<FileUploader {...defaultProps} />);
    const dropZone = screen.getByText(/点击上传或拖拽文件到这里/i);
    fireEvent.dragEnter(dropZone);
    expect(dropZone).toHaveClass('border-blue-500');
    fireEvent.dragLeave(dropZone);
    expect(dropZone).toHaveClass('border-gray-300');
  });
});