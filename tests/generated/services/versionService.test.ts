// AUTO-GENERATED BY generate-tests.ts
// Source: src/services/versionService.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { versionService } from '../../../src/services/versionService';
import { ProjectVersion } from '../../../src/types/project';
import { supabase } from '../../../src/lib/supabase';
import { fileService } from '../../../src/services/fileService';

vi.mock('../../../src/lib/supabase', () => ({
  supabase: {
    auth: {
      getSession: vi.fn(),
    },
    from: vi.fn(),
  },
}));

vi.mock('../../../src/services/fileService', () => ({
  fileService: {
    deleteFile: vi.fn(),
  },
}));

// Mock global fetch
vi.stubGlobal('fetch', vi.fn());

beforeEach(() => {
  vi.clearAllMocks();
});

describe('versionService.createVersion', () => {
  const dummySession = { access_token: 'dummy-token' };
  const supabaseUrl = 'http://test.supabase.io';
  const projectId = 'proj-123';
  const versionNumber = 1;
  const codeSnapshot = { foo: 'bar' };
  const previewUrl = 'http://preview.com';
  const copyFromVersionId = 'ver-0';

  const mockFetchSuccess = async (responseData: any) => {
    (fetch as vi.Mock).mockResolvedValue({
      ok: true,
      json: vi.fn().mockResolvedValue(responseData),
    });
  };

  const mockFetchError = async (status: number, errorData: any) => {
    (fetch as vi.Mock).mockResolvedValue({
      ok: false,
      status,
      json: vi.fn().mockResolvedValue(errorData),
    });
  };

  it.each([
    {
      description: 'with all optional parameters',
      args: [projectId, versionNumber, codeSnapshot, previewUrl, copyFromVersionId],
      mockResponse: { version: { id: 'ver-1' } as ProjectVersion },
    },
    {
      description: 'without previewUrl',
      args: [projectId, versionNumber, codeSnapshot, undefined, copyFromVersionId],
      mockResponse: { version: { id: 'ver-2' } as ProjectVersion },
    },
    {
      description: 'without copyFromVersionId',
      args: [projectId, versionNumber, codeSnapshot, previewUrl, undefined],
      mockResponse: { version: { id: 'ver-3' } as ProjectVersion },
    },
  ]('should create version successfully when $description', async ({ args, mockResponse }) => {
    // Arrange
    (supabase.auth.getSession as vi.Mock).mockResolvedValue({ data: { session: dummySession } });
    vi.stubGlobal('import.meta.env', { VITE_SUPABASE_URL: supabaseUrl });
    await mockFetchSuccess(mockResponse);

    // Act
    const result = await versionService.createVersion(...args);

    // Assert
    expect(result.error).toBeNull();
    expect(result.data).toEqual(mockResponse.version);
    expect(fetch).toHaveBeenCalledWith(`${supabaseUrl}/functions/v1/create-version`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${dummySession.access_token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        projectId,
        versionNumber,
        codeSnapshot,
        previewUrl,
        copyFromVersionId,
      }),
    });
  });

  it('should return unauthorized error when no session', async () => {
    // Arrange
    (supabase.auth.getSession as vi.Mock).mockResolvedValue({ data: { session: null } });

    // Act
    const result = await versionService.createVersion(projectId, versionNumber, codeSnapshot);

    // Assert
    expect(result.data).toBeNull();
    expect(result.error).toBe('未授权');
  });

  it('should handle fetch error response', async () => {
    // Arrange
    (supabase.auth.getSession as vi.Mock).mockResolvedValue({ data: { session: dummySession } });
    vi.stubGlobal('import.meta.env', { VITE_SUPABASE_URL: supabaseUrl });
    await mockFetchError(400, { error: 'Bad Request' });

    // Act
    const result = await versionService.createVersion(projectId, versionNumber, codeSnapshot);

    // Assert
    expect(result.data).toBeNull();
    expect(result.error).toBe('Bad Request');
  });

  it('should handle network exception', async () => {
    // Arrange
    (supabase.auth.getSession as vi.Mock).mockResolvedValue({ data: { session: dummySession } });
    vi.stubGlobal('import.meta.env', { VITE_SUPABASE_URL: supabaseUrl });
    (fetch as vi.Mock).mockRejectedValue(new Error('Network error'));

    // Act
    const result = await versionService.createVersion(projectId, versionNumber, codeSnapshot);

    // Assert
    expect(result.data).toBeNull();
    expect(result.error).toBeInstanceOf(Error);
    expect(result.error.message).toBe('Network error');
  });
});

describe('versionService.getVersionsByProjectId', () => {
  const projectId = 'proj-123';
  const mockData: ProjectVersion[] = [
    { id: 'ver-1', project_id: projectId, version_number: 2 },
    { id: 'ver-2', project_id: projectId, version_number: 1 },
  ];

  it('should return versions list', async () => {
    // Arrange
    const fromMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), order: vi.fn().mockReturnThis() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.select().eq().order().mockResolvedValue({ data: mockData, error: null });

    // Act
    const result = await versionService.getVersionsByProjectId(projectId);

    // Assert
    expect(result.error).toBeNull();
    expect(result.data).toEqual(mockData);
    expect(supabase.from).toHaveBeenCalledWith('project_versions');
  });

  it('should return error when supabase fails', async () => {
    // Arrange
    const errorObj = new Error('Supabase error');
    const fromMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), order: vi.fn().mockReturnThis() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.select().eq().order().mockResolvedValue({ data: null, error: errorObj });

    // Act
    const result = await versionService.getVersionsByProjectId(projectId);

    // Assert
    expect(result.data).toBeNull();
    expect(result.error).toBe(errorObj);
  });
});

describe('versionService.getLatestVersion', () => {
  const projectId = 'proj-123';
  const mockVersion: ProjectVersion = { id: 'ver-1', project_id: projectId, version_number: 3 };

  it('should return latest version', async () => {
    // Arrange
    const fromMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), order: vi.fn().mockReturnThis(), limit: vi.fn().mockReturnThis(), maybeSingle: vi.fn() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.select().eq().order().limit().maybeSingle().mockResolvedValue({ data: mockVersion, error: null });

    // Act
    const result = await versionService.getLatestVersion(projectId);

    // Assert
    expect(result.error).toBeNull();
    expect(result.data).toEqual(mockVersion);
  });

  it('should return null data when no version exists', async () => {
    // Arrange
    const fromMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), order: vi.fn().mockReturnThis(), limit: vi.fn().mockReturnThis(), maybeSingle: vi.fn() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.select().eq().order().limit().maybeSingle().mockResolvedValue({ data: null, error: null });

    // Act
    const result = await versionService.getLatestVersion(projectId);

    // Assert
    expect(result.error).toBeNull();
    expect(result.data).toBeNull();
  });

  it('should propagate supabase error', async () => {
    // Arrange
    const errorObj = new Error('Supabase error');
    const fromMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), order: vi.fn().mockReturnThis(), limit: vi.fn().mockReturnThis(), maybeSingle: vi.fn() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.select().eq().order().limit().maybeSingle().mockResolvedValue({ data: null, error: errorObj });

    // Act
    const result = await versionService.getLatestVersion(projectId);

    // Assert
    expect(result.data).toBeNull();
    expect(result.error).toBe(errorObj);
  });
});

describe('versionService.deleteVersion', () => {
  const versionId = 'ver-123';

  it('should delete version and associated files', async () => {
    // Arrange
    const files = [{ id: 'file-1' }, { id: 'file-2' }];
    const fromFilesMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis() });
    const fromVersionsMock = vi.fn().mockReturnThis({ delete: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis() });
    (supabase.from as vi.Mock).mockImplementation((table: string) => {
      if (table === 'project_files') return fromFilesMock;
      if (table === 'project_versions') return fromVersionsMock;
      return vi.fn();
    });
    fromFilesMock.select().eq().mockResolvedValue({ data: files, error: null });
    fileService.deleteFile.mockResolvedValue(undefined);
    fromVersionsMock.delete().eq().mockResolvedValue({ error: null });

    // Act
    const result = await versionService.deleteVersion(versionId);

    // Assert
    expect(fileService.deleteFile).toHaveBeenCalledTimes(files.length);
    expect(fileService.deleteFile).toHaveBeenCalledWith('file-1');
    expect(fileService.deleteFile).toHaveBeenCalledWith('file-2');
    expect(fromVersionsMock.delete().eq()).toHaveBeenCalled();
    expect(result.error).toBeNull();
  });

  it('should handle no files to delete', async () => {
    // Arrange
    const fromFilesMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis() });
    const fromVersionsMock = vi.fn().mockReturnThis({ delete: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis() });
    (supabase.from as vi.Mock).mockImplementation((table: string) => {
      if (table === 'project_files') return fromFilesMock;
      if (table === 'project_versions') return fromVersionsMock;
      return vi.fn();
    });
    fromFilesMock.select().eq().mockResolvedValue({ data: [], error: null });
    fromVersionsMock.delete().eq().mockResolvedValue({ error: null });

    // Act
    const result = await versionService.deleteVersion(versionId);

    // Assert
    expect(fileService.deleteFile).not.toHaveBeenCalled();
    expect(result.error).toBeNull();
  });

  it('should return error when supabase delete fails', async () => {
    // Arrange
    const errorObj = new Error('Delete error');
    const fromFilesMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis() });
    const fromVersionsMock = vi.fn().mockReturnThis({ delete: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis() });
    (supabase.from as vi.Mock).mockImplementation((table: string) => {
      if (table === 'project_files') return fromFilesMock;
      if (table === 'project_versions') return fromVersionsMock;
      return vi.fn();
    });
    fromFilesMock.select().eq().mockResolvedValue({ data: [], error: null });
    fromVersionsMock.delete().eq().mockResolvedValue({ error: errorObj });

    // Act
    const result = await versionService.deleteVersion(versionId);

    // Assert
    expect(result.error).toBe(errorObj);
  });
});

describe('versionService.getVersionFileStats', () => {
  const versionId = 'ver-123';
  const mockData = { total_files: 5, total_size: 1024 };

  it('should return file stats', async () => {
    // Arrange
    const fromMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), maybeSingle: vi.fn() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.select().eq().maybeSingle().mockResolvedValue({ data: mockData, error: null });

    // Act
    const result = await versionService.getVersionFileStats(versionId);

    // Assert
    expect(result.error).toBeNull();
    expect(result.data).toEqual({ totalFiles: 5, totalSize: 1024 });
  });

  it('should return zero stats when data missing', async () => {
    // Arrange
    const fromMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), maybeSingle: vi.fn() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.select().eq().maybeSingle().mockResolvedValue({ data: null, error: null });

    // Act
    const result = await versionService.getVersionFileStats(versionId);

    // Assert
    expect(result.error).toBeNull();
    expect(result.data).toEqual({ totalFiles: 0, totalSize: 0 });
  });

  it('should propagate supabase error', async () => {
    // Arrange
    const errorObj = new Error('Supabase error');
    const fromMock = vi.fn().mockReturnThis({ select: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), maybeSingle: vi.fn() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.select().eq().maybeSingle().mockResolvedValue({ data: null, error: errorObj });

    // Act
    const result = await versionService.getVersionFileStats(versionId);

    // Assert
    expect(result.data).toBeNull();
    expect(result.error).toBe(errorObj);
  });
});

describe('versionService.updateVersion', () => {
  const versionId = 'ver-123';
  const updates = { version_number: 2, description: 'Updated' };
  const mockVersion: ProjectVersion = { id: versionId, project_id: 'proj-1', version_number: 2 };

  it('should update version successfully', async () => {
    // Arrange
    const fromMock = vi.fn().mockReturnThis({ update: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), select: vi.fn().mockReturnThis(), maybeSingle: vi.fn() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.update().eq().select().maybeSingle().mockResolvedValue({ data: mockVersion, error: null });

    // Act
    const result = await versionService.updateVersion(versionId, updates);

    // Assert
    expect(result.error).toBeNull();
    expect(result.data).toEqual(mockVersion);
  });

  it('should return error when supabase update fails', async () => {
    // Arrange
    const errorObj = new Error('Update error');
    const fromMock = vi.fn().mockReturnThis({ update: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), select: vi.fn().mockReturnThis(), maybeSingle: vi.fn() });
    (supabase.from as vi.Mock).mockReturnValue(fromMock);
    fromMock.update().eq().select().maybeSingle().mockResolvedValue({ data: null, error: errorObj });

    // Act
    const result = await versionService.updateVersion(versionId, updates);

    // Assert
    expect(result.data).toBeNull();
    expect(result.error).toBe(errorObj);
  });
});