// AUTO-GENERATED BY generate-tests.ts
// Source: src/services/templateService.ts
// DO NOT EDIT MANUALLY - ä¿®æ”¹å°†åœ¨ä¸‹æ¬¡ç”Ÿæˆæ—¶è¢«è¦†ç›–

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { templateService } from '../../../src/services/templateService';

vi.mock('../../../src/lib/supabase', () => ({
  supabase: {
    auth: {
      getSession: vi.fn(),
    },
  },
}));

// Mock global fetch
const mockFetch = vi.fn();
vi.stubGlobal('fetch', mockFetch);

// Ensure import.meta.env is available
beforeEach(() => {
  (globalThis as any).import.meta = {
    env: {
      VITE_SUPABASE_URL: 'https://example.com',
    },
  };
  vi.clearAllMocks();
});

describe('templateService.initializeProjectWithTemplate', () => {
  const projectId = 'proj-123';
  const projectTitle = 'Test Project';
  const projectDescription = 'A description';

  // Helper to mock supabase auth session
  const mockSession = (token: string | null) => {
    const getSession = (await import('../../../src/lib/supabase')).supabase.auth.getSession;
    if (token) {
      getSession.mockResolvedValue({ data: { session: { access_token: token } } });
    } else {
      getSession.mockResolvedValue({ data: { session: null } });
    }
  };

  it('should return success when edge function responds with success', async () => {
    mockSession('valid-token');

    const responsePayload = {
      success: true,
      versionId: 'ver-456',
      filesCreated: 10,
      totalSize: 1024,
    };

    mockFetch.mockResolvedValue({
      ok: true,
      json: vi.fn().mockResolvedValue(responsePayload),
    });

    const result = await templateService.initializeProjectWithTemplate(
      projectId,
      projectTitle,
      projectDescription
    );

    expect(result.success).toBe(true);
    expect(result.versionId).toBe(responsePayload.versionId);
    expect(result.error).toBeUndefined();

    const expectedUrl = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/initialize-project`;
    expect(mockFetch).toHaveBeenCalledWith(expectedUrl, {
      method: 'POST',
      headers: {
        Authorization: `Bearer valid-token`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        projectId,
        title: projectTitle,
        description: projectDescription,
      }),
    });
  });

  it('should return failure when edge function responds with non-ok status', async () => {
    mockSession('valid-token');

    const errorPayload = {
      success: false,
      error: 'Invalid project ID',
      details: 'Project ID does not exist',
    };

    mockFetch.mockResolvedValue({
      ok: false,
      json: vi.fn().mockResolvedValue(errorPayload),
    });

    const result = await templateService.initializeProjectWithTemplate(
      projectId,
      projectTitle,
      projectDescription
    );

    expect(result.success).toBe(false);
    expect(result.error).toBe(errorPayload.error);
    expect(result.versionId).toBeUndefined();
  });

  it('should return unauthorized when no session is present', async () => {
    mockSession(null);

    const result = await templateService.initializeProjectWithTemplate(
      projectId,
      projectTitle,
      projectDescription
    );

    expect(result.success).toBe(false);
    expect(result.error).toBe('æœªæŽˆæƒ');
    expect(mockFetch).not.toHaveBeenCalled();
  });

  it('should handle network errors during fetch', async () => {
    mockSession('valid-token');

    mockFetch.mockRejectedValue(new Error('Network failure'));

    const result = await templateService.initializeProjectWithTemplate(
      projectId,
      projectTitle,
      projectDescription
    );

    expect(result.success).toBe(false);
    expect(result.error.message).toBe('Network failure');
  });

  it('should handle JSON parsing errors', async () => {
    mockSession('valid-token');

    mockFetch.mockResolvedValue({
      ok: true,
      json: vi.fn().mockRejectedValue(new Error('Invalid JSON')),
    });

    const result = await templateService.initializeProjectWithTemplate(
      projectId,
      projectTitle,
      projectDescription
    );

    expect(result.success).toBe(false);
    expect(result.error.message).toBe('Invalid JSON');
  });

  test.each([
    ['', '', 'Empty title and description'],
    ['a'.repeat(1000), 'b'.repeat(1000), 'Very long title and description'],
    ['ðŸš€', 'ðŸ§ª', 'Unicode characters'],
    ['null', 'undefined', 'String literals null and undefined'],
  ])(
    'should handle edge cases: %s, %s',
    async (title, description, _case) => {
      mockSession('valid-token');

      const responsePayload = {
        success: true,
        versionId: 'ver-999',
      };

      mockFetch.mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue(responsePayload),
      });

      const result = await templateService.initializeProjectWithTemplate(
        projectId,
        title,
        description
      );

      expect(result.success).toBe(true);
      expect(result.versionId).toBe(responsePayload.versionId);
    }
  );
});