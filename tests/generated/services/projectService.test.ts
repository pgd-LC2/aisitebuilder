// AUTO-GENERATED BY generate-tests.ts
// Source: src/services/projectService.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, test, vi } from 'vitest';
import { projectService } from '../../../src/services/projectService';
import { supabase } from '../../../src/lib/supabase';
import { Project, ProjectStatus } from '../../../src/types/project';

vi.mock('../../../src/lib/supabase', () => ({
  supabase: {
    from: vi.fn()
  }
}));

function createMockFrom({
  insertResult,
  selectResult,
  maybeSingleResult,
  eqResult,
  orderResult,
  limitResult,
  updateResult,
  deleteResult,
  orResult
}: {
  insertResult?: any;
  selectResult?: any;
  maybeSingleResult?: any;
  eqResult?: any;
  orderResult?: any;
  limitResult?: any;
  updateResult?: any;
  deleteResult?: any;
  orResult?: any;
} = {}) {
  const mockFrom: any = {
    insert: vi.fn().mockReturnValue(mockFrom),
    select: vi.fn().mockReturnValue({
      maybeSingle: vi.fn().mockResolvedValue(maybeSingleResult ?? { data: null, error: null })
    }),
    eq: vi.fn().mockReturnValue(mockFrom),
    order: vi.fn().mockReturnValue(mockFrom),
    limit: vi.fn().mockReturnValue(mockFrom),
    update: vi.fn().mockReturnValue({
      maybeSingle: vi.fn().mockResolvedValue(maybeSingleResult ?? { data: null, error: null })
    }),
    delete: vi.fn().mockReturnValue({
      eq: vi.fn().mockResolvedValue(deleteResult ?? { error: null })
    }),
    or: vi.fn().mockReturnValue(mockFrom)
  };

  // Override results if provided
  if (insertResult !== undefined) {
    mockFrom.insert.mockResolvedValue(insertResult);
  }
  if (selectResult !== undefined) {
    mockFrom.select.mockResolvedValue(selectResult);
  }
  if (eqResult !== undefined) {
    mockFrom.eq.mockReturnValue(eqResult);
  }
  if (orderResult !== undefined) {
    mockFrom.order.mockReturnValue(orderResult);
  }
  if (limitResult !== undefined) {
    mockFrom.limit.mockReturnValue(limitResult);
  }
  if (updateResult !== undefined) {
    mockFrom.update.mockResolvedValue(updateResult);
  }
  if (orResult !== undefined) {
    mockFrom.or.mockReturnValue(orResult);
  }

  return mockFrom;
}

describe('projectService', () => {
  const mockProject: Project = {
    id: 'proj-123',
    user_id: 'user-456',
    title: 'Test Project',
    description: 'A description',
    status: 'draft' as ProjectStatus,
    created_at: new Date().toISOString()
  };

  describe('createProject', () => {
    test.each([
      ['user-1', 'Title 1', 'Description 1'],
      ['user-2', 'Special chars !@#$%', 'Desc with newline\nsecond line'],
      ['user-3', '', ''],
      ['user-4', 'a'.repeat(255), 'b'.repeat(500)]
    ])('should create project successfully for userId=%s, title=%s, description=%s', async (userId, title, description) => {
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: mockProject, error: null }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.createProject(userId, title, description);

      expect(result.error).toBeNull();
      expect(result.data).toEqual(mockProject);
      expect(supabase.from).toHaveBeenCalledWith('projects');
      expect(mockFrom.insert).toHaveBeenCalledWith({
        user_id: userId,
        title,
        description,
        status: 'draft'
      });
      expect(mockFrom.select).toHaveBeenCalled();
      expect(mockFrom.maybeSingle).toHaveBeenCalled();
    });

    it('should propagate error when supabase insert fails', async () => {
      const error = new Error('Insert failed');
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: null, error }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.createProject('user-1', 'Title', 'Desc');

      expect(result.error).toBe(error);
      expect(result.data).toBeNull();
    });
  });

  describe('getProjectsByUserId', () => {
    test.each([
      ['user-1', undefined, [{ ...mockProject }, { ...mockProject, id: 'proj-124' }]],
      ['user-2', 1, [{ ...mockProject }]],
      ['user-3', 0, []],
      ['user-4', 1000, [{ ...mockProject }]]
    ])('should fetch projects for userId=%s with limit=%s', async (userId, limit, projects) => {
      const mockFrom = createMockFrom({
        selectResult: { data: projects, error: null }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.getProjectsByUserId(userId, limit);

      expect(result.error).toBeNull();
      expect(result.data).toEqual(projects);
      expect(supabase.from).toHaveBeenCalledWith('projects');
      expect(mockFrom.select).toHaveBeenCalledWith('*');
      expect(mockFrom.eq).toHaveBeenCalledWith('user_id', userId);
      expect(mockFrom.order).toHaveBeenCalledWith('created_at', { ascending: false });
      if (limit) {
        expect(mockFrom.limit).toHaveBeenCalledWith(limit);
      } else {
        expect(mockFrom.limit).not.toHaveBeenCalled();
      }
    });

    it('should propagate error when supabase query fails', async () => {
      const error = new Error('Query failed');
      const mockFrom = createMockFrom({
        selectResult: { data: null, error }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.getProjectsByUserId('user-1');

      expect(result.error).toBe(error);
      expect(result.data).toBeNull();
    });
  });

  describe('getProjectById', () => {
    it('should return project when found', async () => {
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: mockProject, error: null }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.getProjectById('proj-123');

      expect(result.error).toBeNull();
      expect(result.data).toEqual(mockProject);
      expect(mockFrom.eq).toHaveBeenCalledWith('id', 'proj-123');
      expect(mockFrom.maybeSingle).toHaveBeenCalled();
    });

    it('should return null when project not found', async () => {
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: null, error: null }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.getProjectById('non-existent');

      expect(result.error).toBeNull();
      expect(result.data).toBeNull();
    });

    it('should propagate error when supabase query fails', async () => {
      const error = new Error('Select failed');
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: null, error }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.getProjectById('proj-123');

      expect(result.error).toBe(error);
      expect(result.data).toBeNull();
    });
  });

  describe('updateProjectStatus', () => {
    test.each([
      ['proj-123', 'active' as ProjectStatus],
      ['proj-124', 'completed' as ProjectStatus],
      ['proj-125', 'archived' as ProjectStatus]
    ])('should update status to %s', async (projectId, status) => {
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: { ...mockProject, status }, error: null }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.updateProjectStatus(projectId, status);

      expect(result.error).toBeNull();
      expect(result.data?.status).toBe(status);
      expect(mockFrom.update).toHaveBeenCalledWith({ status });
      expect(mockFrom.eq).toHaveBeenCalledWith('id', projectId);
      expect(mockFrom.maybeSingle).toHaveBeenCalled();
    });

    it('should propagate error when supabase update fails', async () => {
      const error = new Error('Update failed');
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: null, error }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.updateProjectStatus('proj-123', 'active' as ProjectStatus);

      expect(result.error).toBe(error);
      expect(result.data).toBeNull();
    });
  });

  describe('updateProject', () => {
    test.each([
      ['proj-123', { title: 'New Title' }],
      ['proj-124', { description: 'New Description', status: 'completed' as ProjectStatus }],
      ['proj-125', { title: '', description: '' }]
    ])('should apply partial updates %s', async (projectId, updates) => {
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: { ...mockProject, ...updates }, error: null }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.updateProject(projectId, updates);

      expect(result.error).toBeNull();
      expect(result.data).toMatchObject(updates);
      expect(mockFrom.update).toHaveBeenCalledWith(updates);
      expect(mockFrom.eq).toHaveBeenCalledWith('id', projectId);
      expect(mockFrom.maybeSingle).toHaveBeenCalled();
    });

    it('should propagate error when supabase update fails', async () => {
      const error = new Error('Update failed');
      const mockFrom = createMockFrom({
        maybeSingleResult: { data: null, error }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.updateProject('proj-123', { title: 'Bad' });

      expect(result.error).toBe(error);
      expect(result.data).toBeNull();
    });
  });

  describe('deleteProject', () => {
    it('should delete project successfully', async () => {
      const mockFrom = createMockFrom({
        deleteResult: { error: null }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.deleteProject('proj-123');

      expect(result.error).toBeNull();
      expect(mockFrom.delete).toHaveBeenCalled();
      expect(mockFrom.eq).toHaveBeenCalledWith('id', 'proj-123');
    });

    it('should propagate error when supabase delete fails', async () => {
      const error = new Error('Delete failed');
      const mockFrom = createMockFrom({
        deleteResult: { error }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.deleteProject('proj-123');

      expect(result.error).toBe(error);
    });
  });

  describe('searchProjects', () => {
    test.each([
      ['user-1', 'Test', [{ ...mockProject }]],
      ['user-2', 'Special!@#', [{ ...mockProject, title: 'Special!@# Project' }]],
      ['user-3', '', []],
      ['user-4', 'a'.repeat(50), [{ ...mockProject, description: 'a'.repeat(200) }]]
    ])('should return matching projects for userId=%s and searchTerm=%s', async (userId, searchTerm, results) => {
      const mockFrom = createMockFrom({
        selectResult: { data: results, error: null }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.searchProjects(userId, searchTerm);

      expect(result.error).toBeNull();
      expect(result.data).toEqual(results);
      expect(supabase.from).toHaveBeenCalledWith('projects');
      expect(mockFrom.select).toHaveBeenCalledWith('*');
      expect(mockFrom.eq).toHaveBeenCalledWith('user_id', userId);
      expect(mockFrom.or).toHaveBeenCalledWith(
        `title.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`
      );
      expect(mockFrom.order).toHaveBeenCalledWith('created_at', { ascending: false });
    });

    it('should propagate error when supabase search fails', async () => {
      const error = new Error('Search failed');
      const mockFrom = createMockFrom({
        selectResult: { data: null, error }
      });
      (supabase.from as vi.Mock).mockReturnValue(mockFrom);

      const result = await projectService.searchProjects('user-1', 'Test');

      expect(result.error).toBe(error);
      expect(result.data).toBeNull();
    });
  });
});