// AUTO-GENERATED BY generate-tests.ts
// Source: src/services/promptService.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, test, expect, vi, beforeEach } from 'vitest';
import { promptService } from '../../../src/services/promptService';
import { supabase } from '../lib/supabase';
import { Prompt, PromptCategory } from '../../../src/types/project';

vi.mock('../lib/supabase', () => ({
  supabase: {
    from: vi.fn()
  }
}));

/**
 * Helper to create a mock table object that mimics Supabase query chaining.
 * @param {object} result - The resolved value for maybeSingle or select.
 * @returns {object} Mock table with chainable methods.
 */
function createTableMock(result: { data: any; error: any }) {
  const tableMock: any = {};
  tableMock.select = vi.fn().mockReturnValue(tableMock);
  tableMock.eq = vi.fn().mockReturnValue(tableMock);
  tableMock.maybeSingle = vi.fn().mockResolvedValue(result);
  tableMock.order = vi.fn().mockReturnValue(tableMock);
  tableMock.in = vi.fn().mockReturnValue(tableMock);
  return tableMock;
}

beforeEach(() => {
  vi.clearAllMocks();
});

describe('promptService', () => {
  describe('getPromptByKey', () => {
    test.each([
      {
        name: 'returns prompt when key exists',
        key: 'greeting',
        mockResult: { data: { id: 1, key: 'greeting', content: 'Hello', is_active: true, category: PromptCategory.GENERAL } as Prompt, error: null },
        expectedData: { id: 1, key: 'greeting', content: 'Hello', is_active: true, category: PromptCategory.GENERAL } as Prompt
      },
      {
        name: 'returns null when key does not exist',
        key: 'nonexistent',
        mockResult: { data: null, error: null },
        expectedData: null
      },
      {
        name: 'handles empty key gracefully',
        key: '',
        mockResult: { data: null, error: null },
        expectedData: null
      },
      {
        name: 'propagates error from Supabase',
        key: 'errorKey',
        mockResult: { data: null, error: new Error('Supabase error') },
        expectedError: new Error('Supabase error')
      }
    ])('$name', async ({ key, mockResult, expectedData, expectedError }) => {
      const tableMock = createTableMock(mockResult);
      (supabase.from as vi.Mock).mockReturnValueOnce(tableMock);

      const { data, error } = await promptService.getPromptByKey(key);

      expect(supabase.from).toHaveBeenCalledWith('prompts');
      expect(tableMock.select).toHaveBeenCalledWith('*');
      expect(tableMock.eq).toHaveBeenCalledWith('key', key);
      expect(tableMock.eq).toHaveBeenCalledWith('is_active', true);
      expect(tableMock.maybeSingle).toHaveBeenCalled();

      if (expectedError) {
        expect(error).toEqual(expectedError);
        expect(data).toBeNull();
      } else {
        expect(error).toBeNull();
        expect(data).toEqual(expectedData);
      }
    });
  });

  describe('getPromptsByCategory', () => {
    test.each([
      {
        name: 'returns prompts for existing category',
        category: PromptCategory.GENERAL,
        mockResult: { data: [{ id: 2, key: 'question', content: 'How are you?', is_active: true, category: PromptCategory.GENERAL }], error: null },
        expectedData: [{ id: 2, key: 'question', content: 'How are you?', is_active: true, category: PromptCategory.GENERAL }]
      },
      {
        name: 'returns empty array when no prompts in category',
        category: PromptCategory.TECHNICAL,
        mockResult: { data: [], error: null },
        expectedData: []
      },
      {
        name: 'handles special characters in category',
        category: PromptCategory.GENERAL as any,
        mockResult: { data: null, error: null },
        expectedData: null
      },
      {
        name: 'propagates error from Supabase',
        category: PromptCategory.GENERAL,
        mockResult: { data: null, error: new Error('Supabase error') },
        expectedError: new Error('Supabase error')
      }
    ])('$name', async ({ category, mockResult, expectedData, expectedError }) => {
      const tableMock = createTableMock(mockResult);
      (supabase.from as vi.Mock).mockReturnValueOnce(tableMock);

      const { data, error } = await promptService.getPromptsByCategory(category);

      expect(supabase.from).toHaveBeenCalledWith('prompts');
      expect(tableMock.select).toHaveBeenCalledWith('*');
      expect(tableMock.eq).toHaveBeenCalledWith('category', category);
      expect(tableMock.eq).toHaveBeenCalledWith('is_active', true);
      expect(tableMock.order).toHaveBeenCalledWith('key', { ascending: true });
      expect(tableMock.select).toHaveBeenCalled();

      if (expectedError) {
        expect(error).toEqual(expectedError);
        expect(data).toBeNull();
      } else {
        expect(error).toBeNull();
        expect(data).toEqual(expectedData);
      }
    });
  });

  describe('getAllActivePrompts', () => {
    test.each([
      {
        name: 'returns all active prompts sorted by category and key',
        mockResult: {
          data: [
            { id: 1, key: 'a', content: 'A', is_active: true, category: PromptCategory.GENERAL },
            { id: 2, key: 'b', content: 'B', is_active: true, category: PromptCategory.TECHNICAL }
          ],
          error: null
        },
        expectedData: [
          { id: 1, key: 'a', content: 'A', is_active: true, category: PromptCategory.GENERAL },
          { id: 2, key: 'b', content: 'B', is_active: true, category: PromptCategory.TECHNICAL }
        ]
      },
      {
        name: 'returns empty array when no active prompts',
        mockResult: { data: [], error: null },
        expectedData: []
      },
      {
        name: 'propagates error from Supabase',
        mockResult: { data: null, error: new Error('Supabase error') },
        expectedError: new Error('Supabase error')
      }
    ])('$name', async ({ mockResult, expectedData, expectedError }) => {
      const tableMock = createTableMock(mockResult);
      (supabase.from as vi.Mock).mockReturnValueOnce(tableMock);

      const { data, error } = await promptService.getAllActivePrompts();

      expect(supabase.from).toHaveBeenCalledWith('prompts');
      expect(tableMock.select).toHaveBeenCalledWith('*');
      expect(tableMock.eq).toHaveBeenCalledWith('is_active', true);
      expect(tableMock.order).toHaveBeenCalledWith('category', { ascending: true });
      expect(tableMock.order).toHaveBeenCalledWith('key', { ascending: true });
      expect(tableMock.select).toHaveBeenCalled();

      if (expectedError) {
        expect(error).toEqual(expectedError);
        expect(data).toBeNull();
      } else {
        expect(error).toBeNull();
        expect(data).toEqual(expectedData);
      }
    });
  });

  describe('getMultiplePromptsByKeys', () => {
    test.each([
      {
        name: 'returns prompts matching provided keys',
        keys: ['key1', 'key2'],
        mockResult: {
          data: [
            { id: 3, key: 'key1', content: 'First', is_active: true, category: PromptCategory.GENERAL },
            { id: 4, key: 'key2', content: 'Second', is_active: true, category: PromptCategory.GENERAL }
          ],
          error: null
        },
        expectedData: [
          { id: 3, key: 'key1', content: 'First', is_active: true, category: PromptCategory.GENERAL },
          { id: 4, key: 'key2', content: 'Second', is_active: true, category: PromptCategory.GENERAL }
        ]
      },
      {
        name: 'returns empty array when keys array is empty',
        keys: [],
        mockResult: { data: [], error: null },
        expectedData: []
      },
      {
        name: 'handles large keys array',
        keys: Array.from({ length: 1500 }, (_, i) => `key${i}`),
        mockResult: { data: [], error: null },
        expectedData: []
      },
      {
        name: 'propagates error from Supabase',
        keys: ['errorKey'],
        mockResult: { data: null, error: new Error('Supabase error') },
        expectedError: new Error('Supabase error')
      }
    ])('$name', async ({ keys, mockResult, expectedData, expectedError }) => {
      const tableMock = createTableMock(mockResult);
      (supabase.from as vi.Mock).mockReturnValueOnce(tableMock);

      const { data, error } = await promptService.getMultiplePromptsByKeys(keys);

      expect(supabase.from).toHaveBeenCalledWith('prompts');
      expect(tableMock.select).toHaveBeenCalledWith('*');
      expect(tableMock.in).toHaveBeenCalledWith('key', keys);
      expect(tableMock.eq).toHaveBeenCalledWith('is_active', true);
      expect(tableMock.select).toHaveBeenCalled();

      if (expectedError) {
        expect(error).toEqual(expectedError);
        expect(data).toBeNull();
      } else {
        expect(error).toBeNull();
        expect(data).toEqual(expectedData);
      }
    });
  });
});