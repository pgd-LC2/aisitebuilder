// AUTO-GENERATED BY generate-tests.ts
// Source: src/services/messageService.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, test, vi, beforeEach } from 'vitest';
import { messageService } from '../../../src/services/messageService';
import { ChatMessage, MessageRole } from '../../../src/types/project';
import { supabase } from '../../../src/lib/supabase';
import { subscribeToTable } from '../../../src/realtime/realtimeClient';

vi.mock('../../../src/lib/supabase', () => ({
  supabase: {
    from: vi.fn()
  }
}));

vi.mock('../../../src/realtime/realtimeClient', () => ({
  subscribeToTable: vi.fn()
}));

describe('messageService', () => {
  const mockMessage: ChatMessage = {
    id: 'msg-1',
    project_id: 'proj-1',
    role: MessageRole.USER,
    content: 'Hello',
    metadata: {},
    created_at: new Date().toISOString()
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('addMessage', () => {
    const insertMock = vi.fn();
    const selectMock = vi.fn();
    const maybeSingleMock = vi.fn();

    const fromMock = vi.fn().mockReturnValue({
      insert: insertMock,
      select: selectMock
    });

    beforeEach(() => {
      vi.mocked(supabase.from).mockImplementation(fromMock);
    });

    test.each([
      ['user', 'Hello world', undefined],
      ['assistant', 'Response', { key: 'value' }],
      ['system', '', {}],
      ['user', 'Special chars !@#$%^&*()_+', undefined],
      ['assistant', 'Long content', ' '.repeat(5000)]
    ])(
      'should add message with role %s and content %s',
      async (role, content, metadata) => {
        // Arrange
        const expectedData = { ...mockMessage, role, content, metadata: metadata || {} };
        maybeSingleMock.mockResolvedValue({ data: expectedData, error: null });

        // Act
        const result = await messageService.addMessage('proj-1', role as MessageRole, content, metadata);

        // Assert
        expect(supabase.from).toHaveBeenCalledWith('chat_messages');
        expect(insertMock).toHaveBeenCalledWith({
          project_id: 'proj-1',
          role,
          content,
          metadata: metadata || {}
        });
        expect(selectMock).toHaveBeenCalled();
        expect(maybeSingleMock).toHaveBeenCalled();
        expect(result).toEqual({ data: expectedData, error: null });
      }
    );

    it('should return error when supabase insert fails', async () => {
      // Arrange
      const error = { message: 'Insert failed' };
      maybeSingleMock.mockResolvedValue({ data: null, error });

      // Act
      const result = await messageService.addMessage('proj-1', MessageRole.USER, 'test');

      // Assert
      expect(result).toEqual({ data: null, error });
    });
  });

  describe('getMessagesByProjectId', () => {
    const selectMock = vi.fn();
    const eqMock = vi.fn();
    const orderMock = vi.fn();

    const fromMock = vi.fn().mockReturnValue({
      select: selectMock,
      eq: eqMock,
      order: orderMock
    });

    beforeEach(() => {
      vi.mocked(supabase.from).mockImplementation(fromMock);
    });

    it('should return messages ordered by created_at', async () => {
      // Arrange
      const messages = [mockMessage];
      selectMock.mockResolvedValue({ data: messages, error: null });

      // Act
      const result = await messageService.getMessagesByProjectId('proj-1');

      // Assert
      expect(supabase.from).toHaveBeenCalledWith('chat_messages');
      expect(selectMock).toHaveBeenCalledWith('*');
      expect(eqMock).toHaveBeenCalledWith('project_id', 'proj-1');
      expect(orderMock).toHaveBeenCalledWith('created_at', { ascending: true });
      expect(result).toEqual({ data: messages, error: null });
    });

    it('should return error when supabase select fails', async () => {
      // Arrange
      const error = { message: 'Select failed' };
      selectMock.mockResolvedValue({ data: null, error });

      // Act
      const result = await messageService.getMessagesByProjectId('');

      // Assert
      expect(result).toEqual({ data: null, error });
    });
  });

  describe('getMessageById', () => {
    const selectMock = vi.fn();
    const eqMock = vi.fn();
    const maybeSingleMock = vi.fn();

    const fromMock = vi.fn().mockReturnValue({
      select: selectMock,
      eq: eqMock,
      maybeSingle: maybeSingleMock
    });

    beforeEach(() => {
      vi.mocked(supabase.from).mockImplementation(fromMock);
    });

    it('should return the message with given id', async () => {
      // Arrange
      maybeSingleMock.mockResolvedValue({ data: mockMessage, error: null });

      // Act
      const result = await messageService.getMessageById('msg-1');

      // Assert
      expect(supabase.from).toHaveBeenCalledWith('chat_messages');
      expect(selectMock).toHaveBeenCalledWith('*');
      expect(eqMock).toHaveBeenCalledWith('id', 'msg-1');
      expect(maybeSingleMock).toHaveBeenCalled();
      expect(result).toEqual({ data: mockMessage, error: null });
    });

    it('should return error when supabase select fails', async () => {
      // Arrange
      const error = { message: 'Select failed' };
      maybeSingleMock.mockResolvedValue({ data: null, error });

      // Act
      const result = await messageService.getMessageById('invalid-id');

      // Assert
      expect(result).toEqual({ data: null, error });
    });
  });

  describe('subscribeToMessages', () => {
    const unsubscribeMock = vi.fn();

    beforeEach(() => {
      vi.mocked(subscribeToTable).mockImplementation(() => unsubscribeMock);
    });

    it('should call subscribeToTable with correct parameters and return unsubscribe', () => {
      // Arrange
      const callback = vi.fn();

      // Act
      const { unsubscribe } = messageService.subscribeToMessages('proj-1', callback);

      // Assert
      expect(subscribeToTable).toHaveBeenCalledWith(
        'chat-messages-proj-1',
        'chat_messages',
        'INSERT',
        'project_id=eq.proj-1',
        expect.any(Function)
      );
      expect(unsubscribe).toBe(unsubscribeMock);
    });

    it('should invoke callback when a new message arrives', () => {
      // Arrange
      const callback = vi.fn();
      const message = { ...mockMessage, id: 'msg-2' };
      let internalCallback: (msg: ChatMessage) => void = () => {};

      vi.mocked(subscribeToTable).mockImplementation((_, __, ___, ____, cb) => {
        internalCallback = cb;
        return unsubscribeMock;
      });

      // Act
      messageService.subscribeToMessages('proj-1', callback);
      internalCallback(message);

      // Assert
      expect(callback).toHaveBeenCalledWith(message);
    });
  });

  describe('clearMessages', () => {
    const deleteMock = vi.fn();
    const eqMock = vi.fn();

    const fromMock = vi.fn().mockReturnValue({
      delete: deleteMock,
      eq: eqMock
    });

    beforeEach(() => {
      vi.mocked(supabase.from).mockImplementation(fromMock);
    });

    it('should clear messages for a project', async () => {
      // Arrange
      deleteMock.mockResolvedValue({ error: null });

      // Act
      const result = await messageService.clearMessages('proj-1');

      // Assert
      expect(supabase.from).toHaveBeenCalledWith('chat_messages');
      expect(deleteMock).toHaveBeenCalled();
      expect(eqMock).toHaveBeenCalledWith('project_id', 'proj-1');
      expect(result).toEqual({ error: null });
    });

    it('should return error when supabase delete fails', async () => {
      // Arrange
      const error = { message: 'Delete failed' };
      deleteMock.mockResolvedValue({ error });

      // Act
      const result = await messageService.clearMessages('');

      // Assert
      expect(result).toEqual({ error });
    });
  });
});
