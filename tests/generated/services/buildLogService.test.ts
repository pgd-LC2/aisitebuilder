// AUTO-GENERATED BY generate-tests.ts
// Source: src/services/buildLogService.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, test, vi, beforeEach } from 'vitest';
import { buildLogService } from '../../../src/services/buildLogService';
import { BuildLog, BuildLogType } from '../../../src/types/project';
import { supabase } from '../../../src/lib/supabase';
import { subscribeBuildLogs as subscribeToLogs } from '../../../src/realtime/subscribeBuildLogs';

vi.mock('../../../src/lib/supabase', () => ({
  supabase: {
    from: vi.fn()
  }
}));

vi.mock('../../../src/realtime/subscribeBuildLogs', () => ({
  subscribeBuildLogs: vi.fn()
}));

beforeEach(() => {
  vi.clearAllMocks();
});

describe('buildLogService', () => {
  describe('addBuildLog', () => {
    const mockLog: BuildLog = {
      id: 'log-1',
      project_id: 'proj-1',
      log_type: BuildLogType.INFO,
      message: 'Test message',
      metadata: {},
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    test.each([
      ['proj-1', BuildLogType.INFO, 'Simple message', {}, null],
      ['proj-2', BuildLogType.ERROR, 'Error message', { code: 500 }, null],
      ['proj-3', BuildLogType.WARN, 'Warn message', null, null],
      ['', BuildLogType.INFO, 'Empty projectId', {}, null],
      ['proj-4', BuildLogType.INFO, 'a'.repeat(10000), {}, null] // large message
    ])(
      'should add a log successfully for projectId=%s, type=%s, message=%s',
      async (projectId, logType, message, metadata, expectedError) => {
        const mockMaybeSingle = vi.fn().mockResolvedValue({ data: mockLog, error: expectedError });

        const mockSelect = vi.fn().mockReturnValue({ maybeSingle: mockMaybeSingle });
        const mockInsert = vi.fn().mockReturnValue({ select: mockSelect });
        const mockBuilder = { insert: mockInsert };

        (supabase.from as vi.Mock).mockReturnValue(mockBuilder);

        const result = await buildLogService.addBuildLog(projectId, logType, message, metadata);

        expect(supabase.from).toHaveBeenCalledWith('build_logs');
        expect(mockInsert).toHaveBeenCalledWith({
          project_id: projectId,
          log_type: logType,
          message,
          metadata: metadata || {}
        });
        expect(mockMaybeSingle).toHaveBeenCalled();
        expect(result).toEqual({ data: mockLog, error: expectedError });
      }
    );

    it('should handle error when supabase insert fails', async () => {
      const error = new Error('Insert failed');
      const mockMaybeSingle = vi.fn().mockResolvedValue({ data: null, error });

      const mockSelect = vi.fn().mockReturnValue({ maybeSingle: mockMaybeSingle });
      const mockInsert = vi.fn().mockReturnValue({ select: mockSelect });
      const mockBuilder = { insert: mockInsert };

      (supabase.from as vi.Mock).mockReturnValue(mockBuilder);

      const result = await buildLogService.addBuildLog('proj-5', BuildLogType.INFO, 'msg');

      expect(result).toEqual({ data: null, error });
    });
  });

  describe('getBuildLogsByProjectId', () => {
    const mockLogs: BuildLog[] = [
      {
        id: 'log-1',
        project_id: 'proj-1',
        log_type: BuildLogType.INFO,
        message: 'First log',
        metadata: {},
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      },
      {
        id: 'log-2',
        project_id: 'proj-1',
        log_type: BuildLogType.ERROR,
        message: 'Second log',
        metadata: {},
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
    ];

    test.each([
      ['proj-1', undefined, mockLogs, null],
      ['proj-1', 1, [mockLogs[0]], null],
      ['proj-2', undefined, null, new Error('Not found')]
    ])(
      'should retrieve logs for projectId=%s with limit=%s',
      async (projectId, limit, expectedData, expectedError) => {
        const mockQuery = vi.fn().mockResolvedValue({ data: expectedData, error: expectedError });

        // Build chain: from -> select -> eq -> order -> (limit) -> query
        const mockOrder = vi.fn().mockReturnValue(limit !== undefined ? { limit: vi.fn().mockReturnValue(mockQuery) } : mockQuery);
        const mockEq = vi.fn().mockReturnValue({ order: mockOrder });
        const mockSelect = vi.fn().mockReturnValue({ eq: mockEq });
        const mockBuilder = { select: mockSelect };

        (supabase.from as vi.Mock).mockReturnValue(mockBuilder);

        const result = await buildLogService.getBuildLogsByProjectId(projectId, limit);

        expect(supabase.from).toHaveBeenCalledWith('build_logs');
        expect(mockSelect).toHaveBeenCalledWith('*');
        expect(mockEq).toHaveBeenCalledWith('project_id', projectId);
        expect(mockOrder).toHaveBeenCalledWith('created_at', { ascending: true });
        if (limit !== undefined) {
          const mockLimit = mockOrder().limit;
          expect(mockLimit).toHaveBeenCalledWith(limit);
        }
        expect(result).toEqual({ data: expectedData, error: expectedError });
      }
    );
  });

  describe('subscribeToBuildLogs', () => {
    it('should call subscribeToLogs and return unsubscribe', () => {
      const mockUnsubscribe = vi.fn();
      (subscribeToLogs as vi.Mock).mockReturnValue(mockUnsubscribe);

      const callback = vi.fn();
      const { unsubscribe } = buildLogService.subscribeToBuildLogs('proj-1', callback);

      expect(subscribeToLogs).toHaveBeenCalledWith({
        projectId: 'proj-1',
        onLogCreated: callback,
        onError: expect.any(Function)
      });
      expect(unsubscribe).toBe(mockUnsubscribe);
    });

    it('should handle error callback', () => {
      const mockUnsubscribe = vi.fn();
      (subscribeToLogs as vi.Mock).mockReturnValue(mockUnsubscribe);
      const consoleError = vi.spyOn(console, 'error').mockImplementation(() => {});

      const callback = vi.fn();
      buildLogService.subscribeToBuildLogs('proj-1', callback);

      // Simulate error callback
      const errorCallback = subscribeToLogs.mock.calls[0][0].onError;
      const testError = new Error('Realtime error');
      errorCallback(testError);

      expect(consoleError).toHaveBeenCalledWith('[buildLogService] subscribe error', testError);
      consoleError.mockRestore();
    });
  });

  describe('clearBuildLogs', () => {
    it('should delete logs successfully', async () => {
      const mockDelete = vi.fn().mockResolvedValue({ error: null });
      const mockEq = vi.fn().mockReturnValue({ delete: mockDelete });
      const mockBuilder = { eq: mockEq };

      (supabase.from as vi.Mock).mockReturnValue(mockBuilder);

      const result = await buildLogService.clearBuildLogs('proj-1');

      expect(supabase.from).toHaveBeenCalledWith('build_logs');
      expect(mockEq).toHaveBeenCalledWith('project_id', 'proj-1');
      expect(mockDelete).toHaveBeenCalled();
      expect(result).toEqual({ error: null });
    });

    it('should handle error when delete fails', async () => {
      const error = new Error('Delete failed');
      const mockDelete = vi.fn().mockResolvedValue({ error });
      const mockEq = vi.fn().mockReturnValue({ delete: mockDelete });
      const mockBuilder = { eq: mockEq };

      (supabase.from as vi.Mock).mockReturnValue(mockBuilder);

      const result = await buildLogService.clearBuildLogs('proj-2');

      expect(result).toEqual({ error });
    });
  });
});