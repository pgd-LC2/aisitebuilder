// AUTO-GENERATED BY generate-tests.ts
// Source: src/services/aiTaskService.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, test, vi } from 'vitest';
import { aiTaskService } from '../../../src/services/aiTaskService';
import { AITaskType } from '../../../src/types/project';

vi.mock('../lib/supabase', () => {
  const mockAuth = {
    getUser: vi.fn()
  };
  const mockFunctions = {
    invoke: vi.fn()
  };
  const mockInsert = vi.fn().mockReturnValue({
    select: vi.fn().mockReturnValue({
      maybeSingle: vi.fn()
    })
  });
  const mockSelect = vi.fn().mockReturnValue({
    eq: vi.fn().mockReturnValue({
      maybeSingle: vi.fn()
    }),
    order: vi.fn().mockReturnValue({
      maybeSingle: vi.fn()
    })
  });
  const mockFrom = vi.fn().mockImplementation(() => ({
    insert: mockInsert,
    select: mockSelect
  }));
  const mockChannel = vi.fn().mockImplementation(() => ({
    on: vi.fn().mockImplementation((event, filter, cb) => {
      // Simulate immediate event trigger
      cb({ new: mockTask });
      return mockChannelInstance;
    }),
    subscribe: vi.fn()
  }));
  const mockChannelInstance = {
    on: mockChannel().on,
    subscribe: mockChannel().subscribe
  };

  const mockTask = {
    id: 'task-123',
    project_id: 'proj-123',
    user_id: 'user-123',
    type: AITaskType.GENERATE,
    payload: { key: 'value' },
    status: 'queued',
    created_at: new Date().toISOString()
  };

  return {
    supabase: {
      auth: mockAuth,
      functions: mockFunctions,
      from: mockFrom,
      channel: mockChannel
    }
  };
});

import { supabase } from '../../../src/lib/supabase';

describe('aiTaskService', () => {
  const projectId = 'proj-123';
  const user = { id: 'user-123' };

  describe('addTask', () => {
    const payloads = [
      { key: 'value' },
      {},
      { large: 'x'.repeat(10000) } // large payload
    ];

    test.each(payloads)('should add task successfully with payload %o', async (payload) => {
      supabase.auth.getUser.mockResolvedValue({ data: { user } });

      const expectedData = {
        id: 'task-123',
        project_id: projectId,
        user_id: user.id,
        type: AITaskType.GENERATE,
        payload,
        status: 'queued',
        created_at: new Date().toISOString()
      };
      supabase.from().insert().select().maybeSingle().mockResolvedValue({ data: expectedData, error: null });

      const result = await aiTaskService.addTask(projectId, AITaskType.GENERATE, payload);

      expect(result.error).toBeNull();
      expect(result.data).toEqual(expectedData);
      expect(supabase.auth.getUser).toHaveBeenCalled();
      expect(supabase.from).toHaveBeenCalledWith('ai_tasks');
    });

    it('should return error when user not authenticated', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: null } });

      const result = await aiTaskService.addTask(projectId, AITaskType.GENERATE, {});

      expect(result.error).toBeInstanceOf(Error);
      expect(result.error?.message).toBe('User not authenticated');
      expect(result.data).toBeNull();
    });

    it('should propagate insert error', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user } });
      const insertError = new Error('Insert failed');
      supabase.from().insert().select().maybeSingle().mockResolvedValue({ data: null, error: insertError });

      const result = await aiTaskService.addTask(projectId, AITaskType.GENERATE, {});

      expect(result.error).toBe(insertError);
      expect(result.data).toBeNull();
    });
  });

  describe('triggerProcessor', () => {
    const contexts = [
      { files: ['file1.txt'] },
      undefined,
      { files: [], metadata: { key: 'value' } }
    ];

    test.each(contexts)('should trigger processor with context %o', async (projectFilesContext) => {
      const mockResponse = { result: 'processed' };
      supabase.functions.invoke.mockResolvedValue({ data: mockResponse, error: null });

      const result = await aiTaskService.triggerProcessor(projectId, projectFilesContext);

      expect(result.error).toBeNull();
      expect(result.data).toEqual(mockResponse);
      expect(supabase.functions.invoke).toHaveBeenCalledWith('process-ai-tasks', {
        body: { projectId, projectFilesContext }
      });
    });

    it('should return error when invoke fails', async () => {
      const invokeError = new Error('Invocation failed');
      supabase.functions.invoke.mockResolvedValue({ data: null, error: invokeError });

      const result = await aiTaskService.triggerProcessor(projectId);

      expect(result.error).toBe(invokeError);
      expect(result.data).toBeNull();
    });
  });

  describe('getTask', () => {
    const taskId = 'task-123';

    it('should retrieve task successfully', async () => {
      const mockTask = {
        id: taskId,
        project_id: projectId,
        user_id: 'user-123',
        type: AITaskType.GENERATE,
        payload: { key: 'value' },
        status: 'completed',
        created_at: new Date().toISOString()
      };
      supabase.from().select().eq().maybeSingle().mockResolvedValue({ data: mockTask, error: null });

      const result = await aiTaskService.getTask(taskId);

      expect(result.error).toBeNull();
      expect(result.data).toEqual(mockTask);
      expect(supabase.from).toHaveBeenCalledWith('ai_tasks');
    });

    it('should return null when task not found', async () => {
      supabase.from().select().eq().maybeSingle().mockResolvedValue({ data: null, error: null });

      const result = await aiTaskService.getTask(taskId);

      expect(result.error).toBeNull();
      expect(result.data).toBeNull();
    });

    it('should propagate error from query', async () => {
      const queryError = new Error('Query failed');
      supabase.from().select().eq().maybeSingle().mockResolvedValue({ data: null, error: queryError });

      const result = await aiTaskService.getTask(taskId);

      expect(result.error).toBe(queryError);
      expect(result.data).toBeNull();
    });
  });

  describe('getTasksByProjectId', () => {
    it('should retrieve tasks successfully', async () => {
      const mockTasks = [
        {
          id: 'task-1',
          project_id: projectId,
          user_id: 'user-123',
          type: AITaskType.GENERATE,
          payload: {},
          status: 'queued',
          created_at: new Date().toISOString()
        },
        {
          id: 'task-2',
          project_id: projectId,
          user_id: 'user-123',
          type: AITaskType.GENERATE,
          payload: {},
          status: 'completed',
          created_at: new Date().toISOString()
        }
      ];
      supabase.from().select().eq().order().mockResolvedValue({ data: mockTasks, error: null });

      const result = await aiTaskService.getTasksByProjectId(projectId);

      expect(result.error).toBeNull();
      expect(result.data).toEqual(mockTasks);
      expect(supabase.from).toHaveBeenCalledWith('ai_tasks');
    });

    it('should return empty array when no tasks', async () => {
      supabase.from().select().eq().order().mockResolvedValue({ data: [], error: null });

      const result = await aiTaskService.getTasksByProjectId(projectId);

      expect(result.error).toBeNull();
      expect(result.data).toEqual([]);
    });

    it('should propagate error from query', async () => {
      const queryError = new Error('Order failed');
      supabase.from().select().eq().order().mockResolvedValue({ data: null, error: queryError });

      const result = await aiTaskService.getTasksByProjectId(projectId);

      expect(result.error).toBe(queryError);
      expect(result.data).toBeNull();
    });
  });

  describe('subscribeToTasks', () => {
    const mockTask = {
      id: 'task-123',
      project_id: projectId,
      user_id: 'user-123',
      type: AITaskType.GENERATE,
      payload: { key: 'value' },
      status: 'queued',
      created_at: new Date().toISOString()
    };

    it('should call callback when new task inserted', () => {
      const mockCallback = vi.fn();

      const channel = aiTaskService.subscribeToTasks(projectId, mockCallback);

      // The mock on implementation triggers the callback immediately
      expect(mockCallback).toHaveBeenCalledTimes(1);
      expect(mockCallback).toHaveBeenCalledWith(mockTask);
      expect(channel.subscribe).toHaveBeenCalled();
    });
  });
});