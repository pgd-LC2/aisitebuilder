// AUTO-GENERATED BY generate-tests.ts
// Source: src/services/fileService.ts
// DO NOT EDIT MANUALLY - ä¿®æ”¹å°†åœ¨ä¸‹æ¬¡ç”Ÿæˆæ—¶è¢«è¦†ç›–

import { fileService } from '../../../src/services/fileService';
import { vi, describe, it, expect, beforeEach } from 'vitest';

// Mock the supabase client
vi.mock('../../../src/lib/supabase', () => {
  const storageMock = {
    from: vi.fn().mockImplementation(() => ({
      upload: vi.fn(),
      remove: vi.fn(),
      copy: vi.fn(),
      createSignedUrl: vi.fn()
    }))
  };

  const dbMock = {
    from: vi.fn().mockImplementation(() => ({
      insert: vi.fn(),
      select: vi.fn().mockImplementation(() => ({
        maybeSingle: vi.fn()
      })),
      maybeSingle: vi.fn(),
      delete: vi.fn(),
      update: vi.fn(),
      eq: vi.fn(),
      order: vi.fn()
    }))
  };

  return {
    supabase: {
      storage: storageMock,
      from: dbMock.from
    }
  };
});

import { supabase } from '../../../src/lib/supabase';

describe('fileService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('uploadFile', () => {
    const projectId = 'proj-1';
    const versionId = 'v1';
    const file = new File(['content'], 'test.txt', { type: 'text/plain', size: 123 });
    const category = 'document' as const;
    const sourceType = 'user_upload' as const;
    const folderPath = 'folder/subfolder';

    it('should upload file and insert record successfully', async () => {
      // Arrange
      const uploadMock = supabase.storage.from().upload;
      uploadMock.mockResolvedValue({ error: null });

      const insertMock = supabase.from().insert;
      const maybeSingleMock = supabase.from().select().maybeSingle();
      const mockRecord = {
        id: 'file-1',
        project_id: projectId,
        version_id: versionId,
        file_name: file.name,
        file_path: `${projectId}/v${versionId}/${folderPath}/${file.name}`,
        file_size: file.size,
        mime_type: file.type,
        file_category: category,
        source_type: sourceType,
        is_public: false
      };
      maybeSingleMock.mockResolvedValue({ data: mockRecord, error: null });

      // Act
      const result = await fileService.uploadFile(
        projectId,
        versionId,
        file,
        category,
        sourceType,
        folderPath
      );

      // Assert
      expect(uploadMock).toHaveBeenCalledWith(
        `${projectId}/v${versionId}/${folderPath}/${file.name}`,
        file,
        { cacheControl: '3600', upsert: false }
      );
      expect(insertMock).toHaveBeenCalledWith(mockRecord);
      expect(result).toEqual({ data: mockRecord, error: null });
    });

    it('should return error when upload fails', async () => {
      // Arrange
      const uploadMock = supabase.storage.from().upload;
      uploadMock.mockResolvedValue({ error: 'upload error' });

      // Act
      const result = await fileService.uploadFile(
        projectId,
        versionId,
        file,
        category
      );

      // Assert
      expect(result).toEqual({ data: null, error: 'upload error' });
    });

    it('should remove uploaded file if insert fails', async () => {
      // Arrange
      const uploadMock = supabase.storage.from().upload;
      uploadMock.mockResolvedValue({ error: null });

      const insertMock = supabase.from().insert;
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: null, error: 'insert error' });

      const removeMock = supabase.storage.from().remove;
      removeMock.mockResolvedValue({ error: null });

      // Act
      const result = await fileService.uploadFile(
        projectId,
        versionId,
        file,
        category
      );

      // Assert
      expect(removeMock).toHaveBeenCalledWith([`${projectId}/v${versionId}/${file.name}`]);
      expect(result).toEqual({ data: null, error: 'insert error' });
    });
  });

  describe('uploadMultipleFiles', () => {
    const projectId = 'proj-2';
    const versionId = 'v2';
    const category = 'image' as const;
    const files = [
      new File(['data1'], 'a.png', { type: 'image/png', size: 200 }),
      new File(['data2'], 'b.png', { type: 'image/png', size: 300 })
    ];

    it('should upload all files successfully', async () => {
      // Arrange
      const uploadFileMock = vi.spyOn(fileService, 'uploadFile').mockImplementation(() => {
        return Promise.resolve({
          data: {
            id: 'id',
            project_id: projectId,
            version_id: versionId,
            file_name: 'a.png',
            file_path: `${projectId}/v${versionId}/a.png`,
            file_size: 200,
            mime_type: 'image/png',
            file_category: category,
            source_type: 'user_upload',
            is_public: false
          },
          error: null
        });
      });

      // Act
      const result = await fileService.uploadMultipleFiles(
        projectId,
        versionId,
        files,
        category
      );

      // Assert
      expect(uploadFileMock).toHaveBeenCalledTimes(2);
      expect(result).toEqual({ data: expect.any(Array), error: null });
    });

    it('should collect errors for failed uploads', async () => {
      // Arrange
      const uploadFileMock = vi.spyOn(fileService, 'uploadFile').mockImplementation((_, __, file) => {
        if (file.name === 'b.png') {
          return Promise.resolve({ data: null, error: 'upload failed' });
        }
        return Promise.resolve({
          data: {
            id: 'id',
            project_id: projectId,
            version_id: versionId,
            file_name: file.name,
            file_path: `${projectId}/v${versionId}/${file.name}`,
            file_size: file.size,
            mime_type: file.type,
            file_category: category,
            source_type: 'user_upload',
            is_public: false
          },
          error: null
        });
      });

      // Act
      const result = await fileService.uploadMultipleFiles(
        projectId,
        versionId,
        files,
        category
      );

      // Assert
      expect(uploadFileMock).toHaveBeenCalledTimes(2);
      expect(result.error).toEqual([{ file: 'b.png', error: 'upload failed' }]);
      expect(result.data).toEqual([{ file_name: 'a.png', /* ... */ }]);
    });
  });

  describe('getFilesByProject', () => {
    const projectId = 'proj-3';
    const versionId = 'v3';

    it('should return files when versionId is provided', async () => {
      // Arrange
      const eqMock = supabase.from().eq;
      const orderMock = supabase.from().order;
      const selectMock = supabase.from().select;
      const maybeSingleMock = supabase.from().select().maybeSingle();

      const mockFiles = [
        { id: '1', project_id: projectId, version_id: versionId },
        { id: '2', project_id: projectId, version_id: versionId }
      ];
      maybeSingleMock.mockResolvedValue({ data: mockFiles, error: null });

      // Act
      const result = await fileService.getFilesByProject(projectId, versionId);

      // Assert
      expect(eqMock).toHaveBeenCalledWith('project_id', projectId);
      expect(eqMock).toHaveBeenCalledWith('version_id', versionId);
      expect(orderMock).toHaveBeenCalledWith('created_at', { ascending: false });
      expect(result).toEqual({ data: mockFiles, error: null });
    });

    it('should return files when versionId is omitted', async () => {
      // Arrange
      const eqMock = supabase.from().eq;
      const orderMock = supabase.from().order;
      const selectMock = supabase.from().select;
      const maybeSingleMock = supabase.from().select().maybeSingle();

      const mockFiles = [{ id: '1', project_id: projectId }];
      maybeSingleMock.mockResolvedValue({ data: mockFiles, error: null });

      // Act
      const result = await fileService.getFilesByProject(projectId);

      // Assert
      expect(eqMock).toHaveBeenCalledWith('project_id', projectId);
      expect(eqMock).not.toHaveBeenCalledWith('version_id', expect.anything());
      expect(orderMock).toHaveBeenCalledWith('created_at', { ascending: false });
      expect(result).toEqual({ data: mockFiles, error: null });
    });

    it('should propagate error from query', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: null, error: 'query error' });

      // Act
      const result = await fileService.getFilesByProject(projectId);

      // Assert
      expect(result).toEqual({ data: null, error: 'query error' });
    });
  });

  describe('getFileTree', () => {
    const projectId = 'proj-4';
    const versionId = 'v4';

    it('should build a tree from files', async () => {
      // Arrange
      const mockFiles = [
        {
          id: '1',
          file_path: `${projectId}/v${versionId}/folder1/file1.txt`,
          file_name: 'file1.txt',
          file_size: 100,
          mime_type: 'text/plain',
          file_category: 'document',
          source_type: 'user_upload'
        },
        {
          id: '2',
          file_path: `${projectId}/v${versionId}/folder1/folder2/file2.jpg`,
          file_name: 'file2.jpg',
          file_size: 200,
          mime_type: 'image/jpeg',
          file_category: 'image',
          source_type: 'user_upload'
        }
      ];

      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: mockFiles, error: null });

      // Act
      const result = await fileService.getFileTree(projectId, versionId);

      // Assert
      expect(result.data?.children?.length).toBe(1); // folder1
      const folder1 = result.data?.children?.[0];
      expect(folder1?.name).toBe('folder1');
      expect(folder1?.children?.length).toBe(2);
      const file1 = folder1?.children?.find(c => c.name === 'file1.txt');
      expect(file1?.type).toBe('file');
      const folder2 = folder1?.children?.find(c => c.name === 'folder2');
      expect(folder2?.type).toBe('folder');
      const file2 = folder2?.children?.[0];
      expect(file2?.name).toBe('file2.jpg');
    });

    it('should return error when getFilesByProject fails', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: null, error: 'fetch error' });

      // Act
      const result = await fileService.getFileTree(projectId, versionId);

      // Assert
      expect(result).toEqual({ data: null, error: 'fetch error' });
    });
  });

  describe('downloadFile', () => {
    const fileId = 'file-5';
    const mockRecord = {
      id: fileId,
      file_path: 'proj-5/v1/file.txt'
    };

    it('should return signed URL when file exists', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: mockRecord, error: null });

      const createSignedUrlMock = supabase.storage.from().createSignedUrl;
      createSignedUrlMock.mockResolvedValue({ data: { signedUrl: 'https://signed.url' }, error: null });

      // Act
      const result = await fileService.downloadFile(fileId);

      // Assert
      expect(result).toEqual({ data: 'https://signed.url', error: null });
    });

    it('should return error when file record not found', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: null, error: null });

      // Act
      const result = await fileService.downloadFile(fileId);

      // Assert
      expect(result).toEqual({ data: null, error: new Error('æ–‡ä»¶è®°å½•ä¸å­˜åœ¨') });
    });

    it('should return error when createSignedUrl fails', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: mockRecord, error: null });

      const createSignedUrlMock = supabase.storage.from().createSignedUrl;
      createSignedUrlMock.mockResolvedValue({ data: null, error: 'url error' });

      // Act
      const result = await fileService.downloadFile(fileId);

      // Assert
      expect(result).toEqual({ data: null, error: 'url error' });
    });
  });

  describe('deleteFile', () => {
    const fileId = 'file-6';
    const mockRecord = { file_path: 'proj-6/v1/file.txt' };

    it('should delete file and record successfully', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: mockRecord, error: null });

      const removeMock = supabase.storage.from().remove;
      removeMock.mockResolvedValue({ error: null });

      const deleteMock = supabase.from().delete;
      deleteMock.mockResolvedValue({ error: null });

      // Act
      const result = await fileService.deleteFile(fileId);

      // Assert
      expect(removeMock).toHaveBeenCalledWith([mockRecord.file_path]);
      expect(deleteMock).toHaveBeenCalledWith();
      expect(result).toEqual({ error: null });
    });

    it('should return error when file record not found', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: null, error: null });

      // Act
      const result = await fileService.deleteFile(fileId);

      // Assert
      expect(result).toEqual({ error: new Error('æ–‡ä»¶è®°å½•ä¸å­˜åœ¨') });
    });
  });

  describe('generateShareLink', () => {
    const fileId = 'file-7';
    const mockRecord = {
      id: fileId,
      file_path: 'proj-7/v1/file.txt',
      is_public: false,
      public_url: null,
      share_expires_at: null
    };

    it('should generate signed URL and update record', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: mockRecord, error: null });

      const createSignedUrlMock = supabase.storage.from().createSignedUrl;
      createSignedUrlMock.mockResolvedValue({ data: { signedUrl: 'https://signed.url' }, error: null });

      const updateMock = supabase.from().update;
      updateMock.mockResolvedValue({ error: null });

      // Act
      const result = await fileService.generateShareLink(fileId, 3600);

      // Assert
      expect(result.data?.url).toBe('https://signed.url');
      expect(result.data?.expiresAt).toBeDefined();
      expect(result.error).toBeNull();
    });

    it('should return error when file record not found', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: null, error: null });

      // Act
      const result = await fileService.generateShareLink(fileId);

      // Assert
      expect(result).toEqual({ data: null, error: new Error('æ–‡ä»¶è®°å½•ä¸å­˜åœ¨') });
    });

    it('should return error when createSignedUrl fails', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: mockRecord, error: null });

      const createSignedUrlMock = supabase.storage.from().createSignedUrl;
      createSignedUrlMock.mockResolvedValue({ data: null, error: 'url error' });

      // Act
      const result = await fileService.generateShareLink(fileId);

      // Assert
      expect(result).toEqual({ data: null, error: 'url error' });
    });

    it('should return error when update fails', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: mockRecord, error: null });

      const createSignedUrlMock = supabase.storage.from().createSignedUrl;
      createSignedUrlMock.mockResolvedValue({ data: { signedUrl: 'https://signed.url' }, error: null });

      const updateMock = supabase.from().update;
      updateMock.mockResolvedValue({ error: 'update error' });

      // Act
      const result = await fileService.generateShareLink(fileId);

      // Assert
      expect(result).toEqual({ data: null, error: 'update error' });
    });
  });

  describe('revokeShareLink', () => {
    const fileId = 'file-8';

    it('should set public flags to false', async () => {
      // Arrange
      const updateMock = supabase.from().update;
      updateMock.mockResolvedValue({ error: null });

      // Act
      const result = await fileService.revokeShareLink(fileId);

      // Assert
      expect(updateMock).toHaveBeenCalledWith({
        is_public: false,
        public_url: null,
        share_expires_at: null
      });
      expect(result).toEqual({ error: null });
    });
  });

  describe('copyFilesToNewVersion', () => {
    const sourceVersionId = 'v1';
    const targetVersionId = 'v2';
    const targetProjectId = 'proj-9';
    const sourceFiles = [
      {
        id: '1',
        project_id: 'proj-9',
        version_id: sourceVersionId,
        file_name: 'file1.txt',
        file_path: 'proj-9/v1/file1.txt',
        file_size: 100,
        mime_type: 'text/plain',
        file_category: 'document',
        source_type: 'user_upload'
      }
    ];

    it('should copy all files and update version stats', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: sourceFiles, error: null });

      const copyMock = supabase.storage.from().copy;
      copyMock.mockResolvedValue({ error: null });

      const insertMock = supabase.from().insert;
      const maybeSingleInsertMock = supabase.from().select().maybeSingle();
      maybeSingleInsertMock.mockResolvedValue({ data: { id: 'new-1' }, error: null });

      const updateVersionMock = supabase.from().update;
      updateVersionMock.mockResolvedValue({ error: null });

      // Act
      const result = await fileService.copyFilesToNewVersion(
        sourceVersionId,
        targetVersionId,
        targetProjectId
      );

      // Assert
      expect(copyMock).toHaveBeenCalledWith('proj-9/v1/file1.txt', 'proj-9/v2/file1.txt');
      expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ project_id: targetProjectId, version_id: targetVersionId }));
      expect(updateVersionMock).toHaveBeenCalledWith({
        total_files: 1,
        total_size: 100
      });
      expect(result.error).toBeNull();
      expect(result.data?.length).toBe(1);
    });

    it('should return error when source files fetch fails', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: null, error: 'fetch error' });

      // Act
      const result = await fileService.copyFilesToNewVersion(
        sourceVersionId,
        targetVersionId,
        targetProjectId
      );

      // Assert
      expect(result).toEqual({ data: null, error: 'fetch error' });
    });

    it('should collect errors when copy or insert fails', async () => {
      // Arrange
      const maybeSingleMock = supabase.from().select().maybeSingle();
      maybeSingleMock.mockResolvedValue({ data: sourceFiles, error: null });

      const copyMock = supabase.storage.from().copy;
      copyMock.mockResolvedValue({ error: 'copy error' });

      // Act
      const result = await fileService.copyFilesToNewVersion(
        sourceVersionId,
        targetVersionId,
        targetProjectId
      );

      // Assert
      expect(result.error).toEqual([{ file: 'file1.txt', error: 'copy error' }]);
      expect(result.data).toBeNull();
    });
  });

  describe('formatFileSize', () => {
    test.each([
      [0, '0 B'],
      [1023, '1023.00 B'],
      [1024, '1.00 KB'],
      [1048576, '1.00 MB'],
      [1073741824, '1.00 GB']
    ])('returns "%s" for %d bytes', (bytes, expected) => {
      expect(fileService.formatFileSize(bytes)).toBe(expected);
    });
  });

  describe('getFileIcon', () => {
    test.each([
      ['image/png', 'ðŸ–¼ï¸'],
      ['video/mp4', 'ðŸŽ¥'],
      ['audio/mp3', 'ðŸŽµ'],
      ['application/pdf', 'ðŸ“„'],
      ['application/zip', 'ðŸ“¦'],
      ['application/gzip', 'ðŸ“¦'],
      ['text/plain', 'ðŸ“'],
      ['application/javascript', 'ðŸ“'],
      ['application/json', 'ðŸ“'],
      ['unknown/type', 'ðŸ“Ž']
    ])('returns "%s" for mime type "%s"', (mime, expectedIcon) => {
      expect(fileService.getFileIcon(mime)).toBe(expectedIcon);
    });
  });
});