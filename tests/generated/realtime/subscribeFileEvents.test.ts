// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/subscribeFileEvents.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, vi, test, beforeEach } from 'vitest';
import subscribeFileEvents from '../../../src/realtime/subscribeFileEvents';
import { subscribeToTable } from '../../../src/realtime/realtimeClient';

vi.mock('../../../src/realtime/realtimeClient', () => ({
  subscribeToTable: vi.fn(),
}));

const mockSubscribeToTable = vi.mocked(subscribeToTable);

describe('subscribeFileEvents', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should warn and return no-op when projectId is falsy', () => {
    const consoleWarn = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const unsubscribe = subscribeFileEvents({
      projectId: '',
      onFileCreated: vi.fn(),
    });

    expect(consoleWarn).toHaveBeenCalledWith(
      '[subscribeFileEvents] projectId 为空，跳过订阅'
    );
    expect(mockSubscribeToTable).not.toHaveBeenCalled();
    expect(typeof unsubscribe).toBe('function');
    unsubscribe(); // should not throw
  });

  test.each([
    {
      description: 'all callbacks with versionId',
      options: {
        projectId: 'proj-123',
        versionId: 'ver-456',
        onFileCreated: vi.fn(),
        onFileUpdated: vi.fn(),
        onFileDeleted: vi.fn(),
        onFileEvent: vi.fn(),
        onError: vi.fn(),
        onStatusChange: vi.fn(),
      },
      expectedCalls: 4,
    },
    {
      description: 'only onFileCreated without versionId',
      options: {
        projectId: 'proj-abc',
        onFileCreated: vi.fn(),
      },
      expectedCalls: 1,
    },
    {
      description: 'only onFileEvent',
      options: {
        projectId: 'proj-xyz',
        onFileEvent: vi.fn(),
      },
      expectedCalls: 1,
    },
    {
      description: 'only onFileUpdated and onFileDeleted',
      options: {
        projectId: 'proj-789',
        onFileUpdated: vi.fn(),
        onFileDeleted: vi.fn(),
      },
      expectedCalls: 2,
    },
  ])(
    'should subscribe correctly when $description',
    ({ options, expectedCalls }) => {
      const unsubscribeMocks = Array.from({ length: expectedCalls }, () => vi.fn());
      mockSubscribeToTable.mockImplementationOnce(() => unsubscribeMocks[0])
        .mockImplementationOnce(() => unsubscribeMocks[1])
        .mockImplementationOnce(() => unsubscribeMocks[2])
        .mockImplementationOnce(() => unsubscribeMocks[3]);

      const unsubscribe = subscribeFileEvents(options);

      expect(mockSubscribeToTable).toHaveBeenCalledTimes(expectedCalls);

      // Verify arguments for create channel (if onFileCreated present)
      if (options.onFileCreated) {
        const createArgs = mockSubscribeToTable.mock.calls.find(
          (call) => call[0].includes('file-events-create')
        );
        expect(createArgs).toBeDefined();
        const [, , , , , callback, onStatusChange] = createArgs!;
        // Simulate a file creation event
        const file = { file_name: 'test.txt', id: '1', project_id: options.projectId };
        callback(file);
        expect(options.onFileCreated).toHaveBeenCalledWith(file);
        expect(onStatusChange).toBe(options.onStatusChange);
      }

      // Simulate update event
      if (options.onFileUpdated) {
        const updateArgs = mockSubscribeToTable.mock.calls.find(
          (call) => call[0].includes('file-events-update')
        );
        const [, , , , , callback] = updateArgs!;
        const file = { file_name: 'update.txt', id: '2', project_id: options.projectId };
        callback(file);
        expect(options.onFileUpdated).toHaveBeenCalledWith(file);
      }

      // Simulate delete event
      if (options.onFileDeleted) {
        const deleteArgs = mockSubscribeToTable.mock.calls.find(
          (call) => call[0].includes('file-events-delete')
        );
        const [, , , , , callback] = deleteArgs!;
        const payload = { id: '3' };
        callback(payload);
        expect(options.onFileDeleted).toHaveBeenCalledWith(payload.id);
      }

      // Simulate file_event event
      if (options.onFileEvent) {
        const fileEventArgs = mockSubscribeToTable.mock.calls.find(
          (call) => call[0].includes('file-events-table')
        );
        const [, , , , , callback] = fileEventArgs!;
        const event = { id: 'e1', op: 'INSERT', path: '/path/file.txt' };
        callback(event);
        expect(options.onFileEvent).toHaveBeenCalledWith(event);
      }

      // Unsubscribe should call all unsubscribe mocks
      unsubscribe();
      unsubscribeMocks.forEach((fn) => expect(fn).toHaveBeenCalled());
    }
  );

  it('should call onError when subscribeToTable throws', () => {
    const error = new Error('subscription failed');
    mockSubscribeToTable.mockImplementationOnce(() => {
      throw error;
    });

    const onError = vi.fn();
    subscribeFileEvents({
      projectId: 'proj-error',
      onFileCreated: vi.fn(),
      onError,
    });

    expect(onError).toHaveBeenCalledWith(error);
  });

  test.each([
    { projectId: '', description: 'empty string projectId' },
    { projectId: 'a'.repeat(1000), description: 'very large projectId' },
    { projectId: 'proj!@#$', description: 'projectId with special chars' },
  ])(
    'boundary test: $description',
    ({ projectId }) => {
      const unsubscribeMocks = Array.from({ length: 3 }, () => vi.fn());
      mockSubscribeToTable.mockImplementationOnce(() => unsubscribeMocks[0])
        .mockImplementationOnce(() => unsubscribeMocks[1])
        .mockImplementationOnce(() => unsubscribeMocks[2]);

      const unsubscribe = subscribeFileEvents({
        projectId,
        onFileCreated: vi.fn(),
        onFileUpdated: vi.fn(),
        onFileDeleted: vi.fn(),
      });

      if (!projectId) {
        expect(mockSubscribeToTable).not.toHaveBeenCalled();
        const consoleWarn = vi.spyOn(console, 'warn').mockImplementation(() => {});
        expect(consoleWarn).toHaveBeenCalledWith(
          '[subscribeFileEvents] projectId 为空，跳过订阅'
        );
      } else {
        expect(mockSubscribeToTable).toHaveBeenCalledTimes(3);
      }

      unsubscribe();
      unsubscribeMocks.forEach((fn) => expect(fn).toHaveBeenCalled());
    }
  );
});