// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/hooks/useAgentEvents.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { renderHook, act } from '@testing-library/react';
import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
import { useRef } from 'react';
import { useAgentEvents } from '../../../src/realtime/hooks/useAgentEvents';

// Mock external services
vi.mock('../../../src/services/messageService', () => ({
  messageService: {
    getMessagesByProjectId: vi.fn(),
    getMessageById: vi.fn(),
  },
}));

vi.mock('../../../src/services/aiTaskService', () => ({
  aiTaskService: {
    getTasksByProjectId: vi.fn(),
  },
}));

vi.mock('../../../src/services/imageProxyService', () => ({
  imageProxyService: {
    fetchImage: vi.fn(),
  },
}));

vi.mock('../../../src/realtime/subscribeAgentEvents', () => ({
  subscribeAgentEvents: vi.fn(),
}));

vi.mock('../../../src/contexts/AuthContext', () => ({
  useAuth: vi.fn(),
}));

vi.mock('../../../src/realtime/realtimeClient', () => ({
  getRealtimeClient: vi.fn(),
}));

// Mock URL methods
global.URL.createObjectURL = vi.fn(() => 'blob:url');
global.URL.revokeObjectURL = vi.fn();

// Helper to advance timers
const advanceTimers = async (ms: number) => {
  await vi.advanceTimersByTimeAsync(ms);
};

describe('useAgentEvents', () => {
  const { messageService } = await import('../../../src/services/messageService');
  const { aiTaskService } = await import('../../../src/services/aiTaskService');
  const { imageProxyService } = await import('../../../src/services/imageProxyService');
  const { subscribeAgentEvents } = await import('../../../src/realtime/subscribeAgentEvents');
  const { useAuth } = await import('../../../src/contexts/AuthContext');
  const { getRealtimeClient } = await import('../../../src/realtime/realtimeClient');

  const mockClient = {
    isGenerationValid: vi.fn(() => true),
    getSessionGeneration: vi.fn(() => 1),
  };

  beforeEach(() => {
    vi.useFakeTimers();
    vi.clearAllMocks();
    getRealtimeClient.mockReturnValue(mockClient);
    useAuth.mockReturnValue({ authReady: true, authVersion: 'v1' });
    subscribeAgentEvents.mockImplementation(() => vi.fn());
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should initialize with empty state when projectId is null', async () => {
    const { result } = renderHook(() => useAgentEvents({ projectId: null, onTaskCompleted: vi.fn(), onMessageReceived: vi.fn() }));

    expect(result.current.messages).toEqual([]);
    expect(result.current.isConnected).toBe(false);
    expect(result.current.isProcessing).toBe(false);
    expect(result.current.lastError).toBe(null);
  });

  it('should load messages and tasks on mount and set images', async () => {
    const mockMessages = [
      { id: 'msg1', role: 'user', content: 'hi' },
      { id: 'msg2', role: 'assistant', content: 'hello' },
    ];
    const mockTasks = [
      {
        id: 'task1',
        type: 'chat_reply',
        status: 'completed',
        result: {
          messageId: 'msg2',
          generated_images: ['img1.png', 'img2.png'],
        },
        project_id: 'proj1',
      },
    ];
    const mockBlob = new Blob(['data'], { type: 'image/png' });

    messageService.getMessagesByProjectId.mockResolvedValue({ data: mockMessages, error: null });
    aiTaskService.getTasksByProjectId.mockResolvedValue({ data: mockTasks, error: null });
    imageProxyService.fetchImage.mockResolvedValue({ data: mockBlob, error: null });

    const { result, waitForNextUpdate } = renderHook(() =>
      useAgentEvents({
        projectId: 'proj1',
        onTaskCompleted: vi.fn(),
        onMessageReceived: vi.fn(),
      })
    );

    // Wait for async refreshMessages to complete
    await waitForNextUpdate();

    expect(messageService.getMessagesByProjectId).toHaveBeenCalledWith('proj1');
    expect(aiTaskService.getTasksByProjectId).toHaveBeenCalledWith('proj1');
    expect(imageProxyService.fetchImage).toHaveBeenCalledTimes(2);
    expect(imageProxyService.fetchImage).toHaveBeenCalledWith('img1.png');
    expect(imageProxyService.fetchImage).toHaveBeenCalledWith('img2.png');

    expect(result.current.messages).toEqual(mockMessages);
    expect(result.current.messageImages).toEqual({
      msg2: ['img1.png', 'img2.png'],
    });
    expect(result.current.imageBlobUrls).toEqual({
      'img1.png': 'blob:url',
      'img2.png': 'blob:url',
    });
    expect(URL.createObjectURL).toHaveBeenCalledTimes(2);
  });

  it('should handle task update (completed) and fetch missing message', async () => {
    const mockMessage = { id: 'msg3', role: 'assistant', content: 'generated' };
    messageService.getMessageById.mockResolvedValue({ data: mockMessage, error: null });

    const { result, waitForNextUpdate } = renderHook(() =>
      useAgentEvents({
        projectId: 'proj1',
        onTaskCompleted: vi.fn(),
        onMessageReceived: vi.fn(),
      })
    );

    // Simulate task update via subscribe callback
    const subscribeArgs = subscribeAgentEvents.mock.calls[0][0];
    const mockTask = {
      id: 'task2',
      type: 'chat_reply',
      status: 'completed',
      result: {
        messageId: 'msg3',
        generated_images: ['img3.png'],
      },
      project_id: 'proj1',
    };

    await act(async () => {
      await subscribeArgs.onTaskUpdate(mockTask);
    });

    expect(aiTaskService.getTasksByProjectId).not.toHaveBeenCalled();
    expect(messageService.getMessageById).toHaveBeenCalledWith('msg3');
    expect(result.current.messages).toContainEqual(mockMessage);
    expect(result.current.messageImages).toEqual({
      msg3: ['img3.png'],
    });
  });

  it('should trigger delayed refresh when message not found after task completion', async () => {
    messageService.getMessageById.mockResolvedValue({ data: null, error: null });
    messageService.getMessagesByProjectId.mockResolvedValue({ data: [], error: null });

    const { result } = renderHook(() =>
      useAgentEvents({
        projectId: 'proj1',
        onTaskCompleted: vi.fn(),
        onMessageReceived: vi.fn(),
      })
    );

    const subscribeArgs = subscribeAgentEvents.mock.calls[0][0];
    const mockTask = {
      id: 'task3',
      type: 'chat_reply',
      status: 'completed',
      result: {
        messageId: 'msg4',
        generated_images: [],
      },
      project_id: 'proj1',
    };

    await act(async () => {
      await subscribeArgs.onTaskUpdate(mockTask);
    });

    // Fast-forward 500ms delay
    await advanceTimers(500);

    expect(messageService.getMessagesByProjectId).toHaveBeenCalledWith('proj1');
  });

  it('should handle task failure and set error state', async () => {
    const mockError = new Error('task failed');
    const { result } = renderHook(() =>
      useAgentEvents({
        projectId: 'proj1',
        onTaskCompleted: vi.fn(),
        onMessageReceived: vi.fn(),
      })
    );

    const subscribeArgs = subscribeAgentEvents.mock.calls[0][0];
    const mockTask = {
      id: 'task4',
      type: 'chat_reply',
      status: 'failed',
      error: mockError.message,
      project_id: 'proj1',
    };

    await act(async () => {
      await subscribeArgs.onTaskUpdate(mockTask);
    });

    expect(result.current.lastError).toBe(mockError.message);
    expect(result.current.isProcessing).toBe(false);
  });

  it('should handle status change SUBSCRIBED and set connection', async () => {
    const { result } = renderHook(() =>
      useAgentEvents({
        projectId: 'proj1',
        onTaskCompleted: vi.fn(),
        onMessageReceived: vi.fn(),
      })
    );

    const subscribeArgs = subscribeAgentEvents.mock.calls[0][0];

    await act(async () => {
      subscribeArgs.onStatusChange('SUBSCRIBED', null, { closeReason: null, isExpectedClose: false });
    });

    expect(result.current.isConnected).toBe(true);

    // RefreshMessages should be called after 250ms
    await advanceTimers(250);
    expect(messageService.getMessagesByProjectId).toHaveBeenCalledWith('proj1');
  });

  it('should handle error callback and set error state', async () => {
    const mockError = new Error('subscription error');
    const { result } = renderHook(() =>
      useAgentEvents({
        projectId: 'proj1',
        onTaskCompleted: vi.fn(),
        onMessageReceived: vi.fn(),
      })
    );

    const subscribeArgs = subscribeAgentEvents.mock.calls[0][0];

    await act(async () => {
      subscribeArgs.onError(mockError);
    });

    expect(result.current.lastError).toBe(mockError.message);
    expect(result.current.isConnected).toBe(false);
    expect(messageService.getMessagesByProjectId).toHaveBeenCalledWith('proj1');
  });

  it('should revoke blob URLs on unmount', async () => {
    const mockMessages = [{ id: 'msg1', role: 'user', content: 'hi' }];
    const mockTasks = [
      {
        id: 'task1',
        type: 'chat_reply',
        status: 'completed',
        result: { messageId: 'msg1', generated_images: ['img1.png'] },
        project_id: 'proj1',
      },
    ];
    const mockBlob = new Blob(['data'], { type: 'image/png' });

    messageService.getMessagesByProjectId.mockResolvedValue({ data: mockMessages, error: null });
    aiTaskService.getTasksByProjectId.mockResolvedValue({ data: mockTasks, error: null });
    imageProxyService.fetchImage.mockResolvedValue({ data: mockBlob, error: null });

    const { unmount } = renderHook(() =>
      useAgentEvents({
        projectId: 'proj1',
        onTaskCompleted: vi.fn(),
        onMessageReceived: vi.fn(),
      })
    );

    // Wait for async effects
    await vi.waitFor(() => expect(imageProxyService.fetchImage).toHaveBeenCalled());

    unmount();

    expect(URL.revokeObjectURL).toHaveBeenCalledWith('blob:url');
  });
});
