// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/hooks/useRealtimeResource.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { useRealtimeResource } from '../../../src/realtime/hooks/useRealtimeResource';
import type { RealtimeResourceConfig } from '../../../src/realtime/types';

vi.mock('../../contexts/AuthContext', () => ({
  useAuth: vi.fn(),
}));

vi.mock('../realtimeClient', () => ({
  getRealtimeClient: vi.fn(),
}));

const mockUseAuth = vi.importMeta.require('../../contexts/AuthContext').useAuth;
const mockGetRealtimeClient = vi.importMeta.require('../realtimeClient').getRealtimeClient;

const dummyItem = { id: '1', name: 'item1' };
const dummyItem2 = { id: '2', name: 'item2' };

function createMockClient() {
  const client = {
    isGenerationValid: vi.fn().mockReturnValue(true),
    getSessionGeneration: vi.fn().mockReturnValue(1),
  };
  mockGetRealtimeClient.mockReturnValue(client);
  return client;
}

function createMockAuth() {
  mockUseAuth.mockReturnValue({
    authReady: true,
    authVersion: 'v1',
  });
}

function createMockSubscribeIncrements(onInsert: any, onUpdate: any, onDelete: any, onStatusChange: any) {
  const unsubscribe = vi.fn();
  const subscribe = vi.fn().mockImplementation((callbacks) => {
    // store callbacks for later manual invocation
    onInsert.mockImplementation(callbacks.onInsert);
    onUpdate.mockImplementation(callbacks.onUpdate);
    onDelete.mockImplementation(callbacks.onDelete);
    onStatusChange.mockImplementation(callbacks.onStatusChange);
    return unsubscribe;
  });
  return { subscribe, unsubscribe };
}

describe('useRealtimeResource', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    createMockAuth();
    createMockClient();
  });

  afterEach(() => {
    vi.clearAllMocks();
    vi.useRealTimers();
  });

  const baseConfig = (fetchSnapshot: () => Promise<any[]>, subscribeIncrements: any): RealtimeResourceConfig<any> => ({
    resourceKey: 'testResource',
    projectId: 'proj-123',
    fetchSnapshot,
    subscribeIncrements,
    getItemId: (item: any) => item.id,
    enabled: true,
    refreshThrottleMs: 1000,
    deps: [],
  });

  it('should fetch snapshot on mount and set data', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem, dummyItem2]);
    const { subscribe, unsubscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    // Initially loading
    expect(result.current.isLoading).toBe(true);
    expect(result.current.data).toEqual([]);

    // Wait for async refresh to finish
    await waitForNextUpdate();

    expect(result.current.isLoading).toBe(false);
    expect(result.current.data).toEqual([dummyItem, dummyItem2]);
    expect(fetchSnapshot).toHaveBeenCalledTimes(1);
    expect(subscribe).toHaveBeenCalledTimes(1);
  });

  it('should set error when fetchSnapshot throws', async () => {
    const errorMsg = 'Network error';
    const fetchSnapshot = vi.fn().mockRejectedValue(new Error(errorMsg));
    const { subscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    expect(result.current.isLoading).toBe(false);
    expect(result.current.error).toBe(errorMsg);
    expect(result.current.data).toEqual([]);
  });

  it.each([
    { throttle: true, expectedCalls: 1 },
    { throttle: false, expectedCalls: 2 },
  ])(
    'refresh throttling: %s',
    async ({ throttle, expectedCalls }) => {
      const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem]);
      const { subscribe } = createMockSubscribeIncrements(
        vi.fn(),
        vi.fn(),
        vi.fn(),
        vi.fn()
      );

      const { result, waitForNextUpdate } = renderHook(() =>
        useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
      );

      await waitForNextUpdate(); // initial fetch

      // Call refresh twice quickly
      act(() => {
        result.current.refresh();
        result.current.refresh();
      });

      // Advance timers to allow throttling window to pass if needed
      vi.advanceTimersByTime(throttle ? 0 : 1000);

      // Wait for any pending async operations
      await act(async () => {
        // no-op, just to flush promises
      });

      expect(fetchSnapshot).toHaveBeenCalledTimes(expectedCalls);
    }
  );

  it('should ignore snapshot if generation is invalid', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem]);
    const client = createMockClient();
    client.isGenerationValid.mockReturnValue(false);

    const { subscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    expect(result.current.data).toEqual([]);
    expect(fetchSnapshot).toHaveBeenCalledTimes(1);
  });

  it('should insert a new item correctly', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem]);
    const { subscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    act(() => {
      result.current.appendItem(dummyItem2);
    });

    expect(result.current.data).toEqual([dummyItem, dummyItem2]);
  });

  it('should update an existing item or add if not present', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem]);
    const { subscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    const updatedItem = { id: '1', name: 'updated' };
    act(() => {
      result.current.updateItem(updatedItem);
    });

    expect(result.current.data).toEqual([updatedItem]);

    const newItem = { id: '3', name: 'new' };
    act(() => {
      result.current.updateItem(newItem);
    });

    expect(result.current.data).toEqual([updatedItem, newItem]);
  });

  it('should delete an item correctly', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem, dummyItem2]);
    const { subscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    act(() => {
      result.current.removeItem('1');
    });

    expect(result.current.data).toEqual([dummyItem2]);
  });

  it('should handle SUBSCRIBED status and trigger refresh after delay', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem]);
    const { subscribe, unsubscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    // Simulate status change
    const onStatusChange = subscribe.mock.calls[0][0].onStatusChange;
    act(() => {
      onStatusChange('SUBSCRIBED', null, { generation: 1 });
    });

    expect(result.current.isConnected).toBe(true);

    // Fast-forward the 250ms delay
    vi.advanceTimersByTime(250);

    await act(async () => {
      // no-op, just to flush promises
    });

    expect(fetchSnapshot).toHaveBeenCalledTimes(2); // initial + refresh due to SUBSCRIBED
  });

  it('should not refresh on expected CLOSE status', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem]);
    const { subscribe, unsubscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    const onStatusChange = subscribe.mock.calls[0][0].onStatusChange;
    act(() => {
      onStatusChange('CLOSED', null, { generation: 1, isExpectedClose: true, closeReason: 'CLEANUP' });
    });

    expect(fetchSnapshot).toHaveBeenCalledTimes(1); // no extra refresh
  });

  it('should refresh once on first unexpected error status', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem]);
    const { subscribe, unsubscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    const onStatusChange = subscribe.mock.calls[0][0].onStatusChange;
    act(() => {
      onStatusChange('CLOSED', new Error('connection lost'), { generation: 1, closeReason: 'TIMED_OUT' });
    });

    expect(fetchSnapshot).toHaveBeenCalledTimes(2); // initial + retry refresh
  });

  it('should not refresh on subsequent error status', async () => {
    const fetchSnapshot = vi.fn().mockResolvedValue([dummyItem]);
    const { subscribe, unsubscribe } = createMockSubscribeIncrements(
      vi.fn(),
      vi.fn(),
      vi.fn(),
      vi.fn()
    );

    const { result, waitForNextUpdate } = renderHook(() =>
      useRealtimeResource(baseConfig(fetchSnapshot, subscribe))
    );

    await waitForNextUpdate();

    const onStatusChange = subscribe.mock.calls[0][0].onStatusChange;
    act(() => {
      // First error triggers refresh
      onStatusChange('CLOSED', new Error('connection lost'), { generation: 1, closeReason: 'TIMED_OUT' });
      // Second error should not trigger another refresh
      onStatusChange('CLOSED', new Error('connection lost'), { generation: 1, closeReason: 'TIMED_OUT' });
    });

    expect(fetchSnapshot).toHaveBeenCalledTimes(2); // initial + one refresh
  });
});