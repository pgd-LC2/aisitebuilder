// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/hooks/useTimelineEvents.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { render, screen, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { useTimelineEvents } from '../../../src/realtime/hooks/useTimelineEvents';
import type {
  DbAgentEvent,
  TimelineEvent,
  AgentPhaseEvent,
  ToolCallEvent,
  FileUpdateEvent,
  SelfRepairEvent,
  LogEvent,
  ErrorEvent,
  AgentPhase,
} from '../../../src/realtime/types';

// Mock the subscribeAgentEvents module
vi.mock('../../../src/realtime/subscribeAgentEvents', () => ({
  subscribeAgentEvents: vi.fn(),
}));

import { subscribeAgentEvents } from '../../../src/realtime/subscribeAgentEvents';

const createTestComponent = (options: { projectId?: string; maxEvents?: number }) => {
  const TestComponent = () => {
    const {
      events,
      phases,
      tools,
      files,
      repairs,
      logs,
      errors,
      currentPhase,
      isConnected,
      addEvent,
      clearEvents,
    } = useTimelineEvents({
      projectId: options.projectId,
      maxEvents: options.maxEvents,
    });

    // Expose state via data-testid for assertions
    return (
      <div>
        <pre data-testid="events">{JSON.stringify(events)}</pre>
        <pre data-testid="phases">{JSON.stringify(phases)}</pre>
        <pre data-testid="tools">{JSON.stringify(tools)}</pre>
        <pre data-testid="files">{JSON.stringify(files)}</pre>
        <pre data-testid="repairs">{JSON.stringify(repairs)}</pre>
        <pre data-testid="logs">{JSON.stringify(logs)}</pre>
        <pre data-testid="errors">{JSON.stringify(errors)}</pre>
        <pre data-testid="currentPhase">{JSON.stringify(currentPhase)}</pre>
        <pre data-testid="isConnected">{JSON.stringify(isConnected)}</pre>
        <button data-testid="addEvent" onClick={() => addEvent(sampleEvent)}>Add Event</button>
        <button data-testid="clearEvents" onClick={clearEvents}>Clear Events</button>
      </div>
    );
  };
  render(<TestComponent />);
  return {
    getEvents: () => screen.getByTestId('events').textContent,
    getPhases: () => screen.getByTestId('phases').textContent,
    getTools: () => screen.getByTestId('tools').textContent,
    getFiles: () => screen.getByTestId('files').textContent,
    getRepairs: () => screen.getByTestId('repairs').textContent,
    getLogs: () => screen.getByTestId('logs').textContent,
    getErrors: () => screen.getByTestId('errors').textContent,
    getCurrentPhase: () => screen.getByTestId('currentPhase').textContent,
    getIsConnected: () => screen.getByTestId('isConnected').textContent,
    clickAddEvent: () => act(() => screen.getByTestId('addEvent').click()),
    clickClearEvents: () => act(() => screen.getByTestId('clearEvents').click()),
  };
};

// Sample event used by the test component's addEvent button
const sampleEvent: TimelineEvent = {
  id: 'sample',
  type: 'log',
  timestamp: new Date().toISOString(),
  taskId: '',
  projectId: '',
  payload: {
    level: 'info',
    message: 'sample log',
    metadata: {},
  },
};

describe('useTimelineEvents Hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should clear events and set isConnected false when projectId is undefined', async () => {
    const {
      getEvents,
      getIsConnected,
      getCurrentPhase,
    } = createTestComponent({ projectId: undefined });

    // Wait for effect to run
    await act(async () => {});

    expect(getIsConnected()).toBe('false');
    expect(getEvents()).toBe('[]');
    expect(getCurrentPhase()).toBe('null');
  });

  it('should subscribe to agent_events and set isConnected true when projectId is provided', async () => {
    const mockUnsubscribe = vi.fn();
    (subscribeAgentEvents as any).mockImplementation(() => mockUnsubscribe);

    const { getIsConnected } = createTestComponent({ projectId: 'proj1' });

    await act(async () => {});

    expect(subscribeAgentEvents).toHaveBeenCalledWith(
      expect.objectContaining({
        projectId: 'proj1',
        onAgentEvent: expect.any(Function),
        onError: expect.any(Function),
      })
    );
    expect(getIsConnected()).toBe('true');
  });

  it('should handle onAgentEvent correctly and prevent duplicate events', async () => {
    const mockUnsubscribe = vi.fn();
    const onAgentEvent = vi.fn();
    (subscribeAgentEvents as any).mockImplementation((opts) => {
      onAgentEvent.mockImplementation(opts.onAgentEvent);
      return mockUnsubscribe;
    });

    const {
      getEvents,
      getPhases,
      getTools,
      getFiles,
      getRepairs,
      getLogs,
      getErrors,
      getCurrentPhase,
      clickClearEvents,
    } = createTestComponent({ projectId: 'proj2' });

    await act(async () => {});

    const dbEvent: DbAgentEvent = {
      id: 'event1',
      task_id: '',
      project_id: '',
      type: 'agent_phase',
      payload: {
        phase: 'Coder',
        status: 'running',
        taskType: 'analysis',
      },
      created_at: new Date().toISOString(),
    };

    // First call should add event
    act(() => onAgentEvent(dbEvent));
    expect(getCurrentPhase()).toBe(JSONcoder');

    // Duplicate call should be ignored
    act(() => onAgentEvent(dbEvent));
    expect(getEvents()).toBe('[]'); // No new events added

    // Add a tool_call event
    const toolEvent: DbAgentEvent = {
      id: 'event2',
      task_id: '',
      project_id: '',
      type: 'tool_call',
      payload: {
        toolName: 'git',
        status: 'success',
        result: 'committed',
        toolArgs: { commitMessage: 'test' },
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(toolEvent));
    expect(getTools()).toContain('tool_call');

    // Clear events
    clickClearEvents();
    expect(getEvents()).toBe('[]');
    expect(getPhases()).toBe('[]');
    expect(getTools()).toBe('[]');
    expect(getCurrentPhase()).toBe('null');
  });

  it('should correctly parse different DbAgentEvent types to TimelineEvent', async () => {
    const mockUnsubscribe = vi.fn();
    const onAgentEvent = vi.fn();
    (subscribeAgentEvents as any).mockImplementation((opts) => {
      onAgentEvent.mockImplementation(opts.onAgentEvent);
      return mockUnsubscribe;
    });

    const {
      getEvents,
      getPhases,
      getTools,
      getFiles,
      getRepairs,
      getLogs,
      getErrors,
      getCurrentPhase,
    } = createTestComponent({ projectId: 'proj3' });

    await act(async () => {});

    // agent_phase enter
    const phaseEnter: DbAgentEvent = {
      id: 'phaseEnter',
      task_id: '',
      project_id: '',
      type: 'agent_phase',
      payload: {
        phase: 'Tester',
        status: 'started',
        taskType: 'testing',
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(phaseEnter));
    expect(getPhases()).toContain('agent_phase');
    expect(getCurrentPhase()).toBe('tester');

    // agent_phase exit
    const phaseExit: DbAgentEvent = {
      id: 'phaseExit',
      task_id: '',
      project_id: '',
      type: 'agent_phase',
      payload: {
        phase: 'Tester',
        status: 'completed',
        taskType: 'testing',
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(phaseExit));
    expect(getCurrentPhase()).toBe('null');

    // tool_call
    const toolCall: DbAgentEvent = {
      id: 'toolCall',
      task_id: '',
      project_id: '',
      type: 'tool_call',
      payload: {
        toolName: 'curl',
        status: 'success',
        result: '200 OK',
        toolArgs: { url: 'https://example.com' },
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(toolCall));
    expect(getTools()).toContain('tool_call');

    // file_update
    const fileUpdate: DbAgentEvent = {
      id: 'fileUpdate',
      task_id: '',
      project_id: '',
      type: 'file_update',
      payload: {
        path: '/src/index.ts',
        op: 'update',
        summary: 'updated import',
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(fileUpdate));
    expect(getFiles()).toContain('file_update');

    // self_repair
    const selfRepair: DbAgentEvent = {
      id: 'selfRepair',
      task_id: '',
      project_id: '',
      type: 'self_repair',
      payload: {
        attemptNumber: 2,
        maxAttempts: 3,
        status: 'failed',
        errorType: 'TypeError',
        errorMessage: 'undefined is not a function',
        rootCause: 'missing import',
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(selfRepair));
    expect(getRepairs()).toContain('self_repair');

    // error
    const errorEvent: DbAgentEvent = {
      id: 'errorEvent',
      task_id: '',
      project_id: '',
      type: 'error',
      payload: {
        errorType: 'ReferenceError',
        errorMessage: 'x is not defined',
        stack: 'stack trace',
        recoverable: false,
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(errorEvent));
    expect(getErrors()).toContain('error');

    // log
    const logEvent: DbAgentEvent = {
      id: 'logEvent',
      task_id: '',
      project_id: '',
      type: 'log',
      payload: {
        level: 'debug',
        message: 'debugging',
        extra: 'info',
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(logEvent));
    expect(getLogs()).toContain('log');
  });

  it('should respect maxEvents limit', async () => {
    const mockUnsubscribe = vi.fn();
    const onAgentEvent = vi.fn();
    (subscribeAgentEvents as any).mockImplementation((opts) => {
      onAgentEvent.mockImplementation(opts.onAgentEvent);
      return mockUnsubscribe;
    });

    const {
      getEvents,
      getPhases,
      getTools,
      getFiles,
      getRepairs,
      getLogs,
      getErrors,
    } = createTestComponent({ projectId: 'proj4', maxEvents: 3 });

    await act(async () => {});

    // Emit 5 log events
    for (let i = 0; i < 5; i++) {
      const logEvent: DbAgentEvent = {
        id: `log${i}`,
        task_id: '',
        project_id: '',
        type: 'log',
        payload: {
          level: 'info',
          message: `log ${i}`,
        },
        created_at: new Date().toISOString(),
      };
      act(() => onAgentEvent(logEvent));
    }

    // Only last 3 should remain
    const events = JSON.parse(getEvents() ?? '[]') as TimelineEvent[];
    expect(events.length).toBe(3);
    expect(events[0].id).toBe('log2');
    expect(events[2].id).toBe('log4');

    // Repeat for phases
    for (let i = 0; i < 5; i++) {
      const phaseEvent: DbAgentEvent = {
        id: `phase${i}`,
        task_id: '',
        project_id: '',
        type: 'agent_phase',
        payload: {
          phase: 'coder',
          status: i % 2 === 0 ? 'running' : 'completed',
          taskType: 'coding',
        },
        created_at: new Date().toISOString(),
      };
      act(() => onAgentEvent(phaseEvent));
    }

    const phases = JSON.parse(getPhases() ?? '[]') as AgentPhaseEvent[];
    expect(phases.length).toBe(3);
    expect(phases[0].id).toBe('phase2');
    expect(phases[2].id).toBe('phase4');
  });

  it('should clear all state when clearEvents is called', async () => {
    const mockUnsubscribe = vi.fn();
    const onAgentEvent = vi.fn();
    (subscribeAgentEvents as any).mockImplementation((opts) => {
      onAgentEvent.mockImplementation(opts.onAgentEvent);
      return mockUnsubscribe;
    });

    const {
      getEvents,
      getPhases,
      getTools,
      getFiles,
      getRepairs,
      getLogs,
      getErrors,
      getCurrentPhase,
      clickClearEvents,
    } = createTestComponent({ projectId: 'proj5' });

    await act(async () => {});

    const logEvent: DbAgentEvent = {
      id: 'log5',
      task_id: '',
      project_id: '',
      type: 'log',
      payload: {
        level: 'info',
        message: 'log',
      },
      created_at: new Date().toISOString(),
    };
    act(() => onAgentEvent(logEvent));

    expect(getEvents()).not.toBe('[]');
    clickClearEvents();
    expect(getEvents()).toBe('[]');
    expect(getPhases()).toBe('[]');
    expect(getTools()).toBe('[]');
    expect(getFiles()).toBe('[]');
    expect(getRepairs()).toBe('[]');
    expect(getLogs()).toBe('[]');
    expect(getErrors()).toBe('[]');
    expect(getCurrentPhase()).toBe('null');
  });
});