// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/hooks/useFileEvents.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import useFileEvents from '../../../src/realtime/hooks/useFileEvents';
import type { ProjectFile } from '../../../src/types/project';
import type { DbFileEvent } from '../../../src/realtime/types';
import type { RealtimeSubscribeStatus, StatusChangeMeta } from '../../../src/realtime/types';

vi.mock('../../../src/services/fileService', () => ({
  fileService: {
    getFilesByProject: vi.fn(),
  },
}));

vi.mock('../../../src/realtime/subscribeFileEvents', () => ({
  subscribeFileEvents: vi.fn(),
}));

vi.mock('../../../src/realtime/realtimeClient', () => ({
  getRealtimeClient: vi.fn(),
}));

vi.mock('../../../src/contexts/AuthContext', () => ({
  useAuth: vi.fn(),
}));

import { fileService } from '../../../src/services/fileService';
import { subscribeFileEvents } from '../../../src/realtime/subscribeFileEvents';
import { getRealtimeClient } from '../../../src/realtime/realtimeClient';
import { useAuth } from '../../../src/contexts/AuthContext';

const HOT_REFRESH_THROTTLE_MS = 500;

// Helper to create a mock realtime client
function createMockClient() {
  const client = {
    isGenerationValid: vi.fn((gen) => gen === 1),
    getSessionGeneration: vi.fn(() => 1),
  };
  return client;
}

// Helper to capture callbacks passed to subscribeFileEvents
function createCallbackCapture() {
  const capture = {
    onFileCreated: vi.fn(),
    onFileUpdated: vi.fn(),
    onFileDeleted: vi.fn(),
    onFileEvent: vi.fn(),
    onError: vi.fn(),
    onStatusChange: vi.fn(),
  };
  subscribeFileEvents.mockImplementation((options) => {
    capture.onFileCreated = options.onFileCreated;
    capture.onFileUpdated = options.onFileUpdated;
    capture.onFileDeleted = options.onFileDeleted;
    capture.onFileEvent = options.onFileEvent;
    capture.onError = options.onError;
    capture.onStatusChange = options.onStatusChange;
    return vi.fn(); // unsubscribe
  });
  return capture;
}

describe('useFileEvents hook', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should load files on mount and set them in state', async () => {
    const mockFiles: ProjectFile[] = [
      { id: '1', file_name: 'file1.txt', path: '/file1.txt' },
      { id: '2', file_name: 'file2.txt', path: '/file2.txt' },
    ];
    (fileService.getFilesByProject as any).mockResolvedValue({ data: mockFiles, error: null });

    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const { result, waitForNextUpdate } = renderHook(() =>
      useFileEvents({ projectId: 'proj', versionId: 'ver' })
    );

    // Initially loading
    expect(result.current.isLoading).toBe(true);

    // Wait for async refreshFiles to finish
    await act(async () => {
      await Promise.resolve(); // allow pending promises
    });

    expect(result.current.isLoading).toBe(false);
    expect(result.current.files).toEqual(mockFiles);
    expect(result.current.isConnected).toBe(false); // connection status set later

    // Ensure subscribeFileEvents was called with correct callbacks
    expect(subscribeFileEvents).toHaveBeenCalledWith(
      expect.objectContaining({
        projectId: 'proj',
        versionId: 'ver',
        onFileCreated: capture.onFileCreated,
        onFileUpdated: capture.onFileUpdated,
        onFileDeleted: capture.onFileDeleted,
        onFileEvent: capture.onFileEvent,
        onError: capture.onError,
        onStatusChange: capture.onStatusChange,
      })
    );
  });

  it('should handle fileService error gracefully', async () => {
    (fileService.getFilesByProject as any).mockResolvedValue({ data: null, error: new Error('db error') });

    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const { result } = renderHook(() =>
      useFileEvents({ projectId: 'proj', versionId: 'ver' })
    );

    await act(async () => {
      await Promise.resolve();
    });

    expect(result.current.isLoading).toBe(false);
    expect(result.current.files).toEqual([]);
  });

  it('should add a new file when onFileCreated is called', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const { result } = renderHook(() =>
      useFileEvents({ projectId: 'proj' })
    );

    const newFile: ProjectFile = { id: '3', file_name: 'file3.txt', path: '/file3.txt' };

    await act(async () => {
      capture.onFileCreated(newFile);
    });

    expect(result.current.files).toContainEqual(newFile);
  });

  it('should not add duplicate files on onFileCreated', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const initialFile: ProjectFile = { id: '1', file_name: 'file1.txt', path: '/file1.txt' };

    const { result } = renderHook(() =>
      useFileEvents({ projectId: 'proj' })
    );

    await act(async () => {
      capture.onFileCreated(initialFile);
      capture.onFileCreated(initialFile); // duplicate
    });

    expect(result.current.files.length).toBe(1);
  });

  it('should update an existing file when onFileUpdated is called', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const initialFile: ProjectFile = { id: '1', file_name: 'file1.txt', path: '/file1.txt' };

    const { result } = renderHook(() =>
      useFileEvents({ projectId: 'proj' })
    );

    await act(async () => {
      capture.onFileCreated(initialFile);
    });

    const updatedFile: ProjectFile = { id: '1', file_name: 'file1_updated.txt', path: '/file1.txt' };

    await act(async () => {
      capture.onFileUpdated(updatedFile);
    });

    expect(result.current.files).toContainEqual(updatedFile);
  });

  it('should not change state when updating a non-existing file', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const { result } = renderHook(() =>
      useFileEvents({ projectId: 'proj' })
    );

    const nonExisting: ProjectFile = { id: '999', file_name: 'missing.txt', path: '/missing.txt' };

    await act(async () => {
      capture.onFileUpdated(nonExisting);
    });

    expect(result.current.files).toEqual([]);
  });

  it('should delete a file when onFileDeleted is called', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const file1: ProjectFile = { id: '1', file_name: 'file1.txt', path: '/file1.txt' };
    const file2: ProjectFile = { id: '2', file_name: 'file2.txt', path: '/file2.txt' };

    const { result } = renderHook(() =>
      useFileEvents({ projectId: 'proj' })
    );

    await act(async () => {
      capture.onFileCreated(file1);
      capture.onFileCreated(file2);
    });

    await act(async () => {
      capture.onFileDeleted('1');
    });

    expect(result.current.files).toEqual([file2]);
  });

  it('should throttle file events and trigger refresh after THROTTLE_MS', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const refreshFilesSpy = vi.spyOn(useFileEvents.prototype, 'refreshFiles');
    // Since refreshFiles is defined inside hook, we need to capture it via act after render
    let refreshFilesFn: () => Promise<void>;

    const { result } = renderHook(() => {
      const hook = useFileEvents({ projectId: 'proj' });
      refreshFilesFn = hook.refreshFiles;
      return hook;
    });

    const event: DbFileEvent = { op: 'INSERT', path: '/file.txt', id: '123', timestamp: Date.now() };

    await act(async () => {
      capture.onFileEvent(event);
    });

    // Timer should be set
    expect(vi.getTimerCount()).toBe(1);

    // Advance timers to trigger refresh
    await act(async () => {
      vi.advanceTimersByTime(HOT_REFRESH_THROTTLE_MS + 1);
    });

    expect(refreshFilesFn).toHaveBeenCalled();
  });

  it('should dispatch custom file-hot-refresh event after throttling', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const event: DbFileEvent = { op: 'INSERT', path: '/file.txt', id: '123', timestamp: Date.now() };

    const listener = vi.fn();
    window.addEventListener('file-hot-refresh', listener);

    const { result } = renderHook(() =>
      useFileEvents({ projectId: 'proj' })
    );

    await act(async () => {
      capture.onFileEvent(event);
    });

    await act(async () => {
      vi.advanceTimersByTime(HOT_REFRESH_THROTTLE_MS + 1);
    });

    expect(listener).toHaveBeenCalledTimes(1);
    const customEvent = listener.mock.calls[0][0] as CustomEvent;
    expect(customEvent.detail.events).toContainEqual(event);
    expect(customEvent.detail.projectId).toBe('proj');
  });

  it('should handle SUBSCRIBED status change and set isConnected after 250ms', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const refreshFilesSpy = vi.fn();
    // Mock refreshFiles inside hook by overriding
    const { result } = renderHook(() => {
      const hook = useFileEvents({ projectId: 'proj' });
      // @ts-ignore
      hook.refreshFiles = refreshFilesSpy;
      return hook;
    });

    await act(async () => {
      capture.onStatusChange('SUBSCRIBED');
    });

    expect(result.current.isConnected).toBe(true);
    expect(refreshFilesSpy).toHaveBeenCalledTimes(0); // not yet

    await act(async () => {
      vi.advanceTimersByTime(250);
    });

    expect(refreshFilesSpy).toHaveBeenCalledTimes(1);
  });

  it('should set isConnected false on RETRYING status', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const { result } = renderHook(() =>
      useFileEvents({ projectId: 'proj' })
    );

    await act(async () => {
      capture.onStatusChange('RETRYING');
    });

    expect(result.current.isConnected).toBe(false);
  });

  it('should refresh once when entering error status from non-error', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const refreshFilesSpy = vi.fn();

    const { result } = renderHook(() => {
      const hook = useFileEvents({ projectId: 'proj' });
      // @ts-ignore
      hook.refreshFiles = refreshFilesSpy;
      return hook;
    });

    // Initial non-error status
    await act(async () => {
      capture.onStatusChange('SUBSCRIBED');
    });

    // Transition to error
    await act(async () => {
      capture.onStatusChange('CLOSED', new Error('network'), { closeReason: 'NETWORK', isExpectedClose: false } as StatusChangeMeta);
    });

    expect(refreshFilesSpy).toHaveBeenCalledTimes(1);
  });

  it('should not refresh when closing is expected', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const refreshFilesSpy = vi.fn();

    const { result } = renderHook(() => {
      const hook = useFileEvents({ projectId: 'proj' });
      // @ts-ignore
      hook.refreshFiles = refreshFilesSpy;
      return hook;
    });

    // Transition to error with expected close
    await act(async () => {
      capture.onStatusChange('CLOSED', new Error('network'), { closeReason: 'CLEANUP', isExpectedClose: true } as StatusChangeMeta);
    });

    expect(refreshFilesSpy).toHaveBeenCalledTimes(0);
  });

  it('should ignore status change callbacks from old generation', async () => {
    const mockClient = createMockClient();
    mockClient.isGenerationValid.mockReturnValue(false); // simulate old generation
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const refreshFilesSpy = vi.fn();

    const { result } = renderHook(() => {
      const hook = useFileEvents({ projectId: 'proj' });
      // @ts-ignore
      hook.refreshFiles = refreshFilesSpy;
      return hook;
    });

    await act(async () => {
      capture.onStatusChange('CLOSED', new Error('network'), { generation: 0 } as StatusChangeMeta);
    });

    expect(refreshFilesSpy).toHaveBeenCalledTimes(0);
  });

  it('should clean up on unmount: unsubscribe and clear timers', async () => {
    const mockClient = createMockClient();
    (getRealtimeClient as any).mockReturnValue(mockClient);
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });

    const capture = createCallbackCapture();

    const unsubscribeSpy = vi.fn();
    subscribeFileEvents.mockImplementation(() => unsubscribeSpy);

    const { unmount } = renderHook(() =>
      useFileEvents({ projectId: 'proj' })
    );

    // Trigger a file event to set timer
    const event: DbFileEvent = { op: 'INSERT', path: '/file.txt', id: '123', timestamp: Date.now() };
    await act(async () => {
      capture.onFileEvent(event);
    });

    expect(vi.getTimerCount()).toBe(1);

    // Unmount
    await act(async () => {
      unmount();
    });

    expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
    expect(vi.getTimerCount()).toBe(0);
  });
});