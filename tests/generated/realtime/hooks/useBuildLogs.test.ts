// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/hooks/useBuildLogs.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach, test } from 'vitest';
import type { BuildLog } from '../../../src/types/project';
import { useBuildLogs } from '../../../src/realtime/hooks/useBuildLogs';
import { buildLogService } from '../../../src/services/buildLogService';
import { subscribeBuildLogs } from '../../../src/realtime/hooks/subscribeBuildLogs';
import { getRealtimeClient } from '../../../src/realtime/hooks/realtimeClient';
import { useAuth } from '../../../src/contexts/AuthContext';
import type {
  RealtimeSubscribeStatus,
  StatusChangeMeta
} from '../../../src/realtime/hooks/types';

// Mock console to avoid noisy logs during tests
vi.spyOn(console, 'log').mockImplementation(() => {});
vi.spyOn(console, 'error').mockImplementation(() => {});

// Mock external modules
vi.mock('../../../src/services/buildLogService', () => ({
  buildLogService: {
    getBuildLogsByProjectId: vi.fn()
  }
}));

vi.mock('../../../src/realtime/hooks/subscribeBuildLogs', () => ({
  subscribeBuildLogs: vi.fn()
}));

vi.mock('../../../src/realtime/hooks/realtimeClient', () => ({
  getRealtimeClient: vi.fn()
}));

vi.mock('../../../src/contexts/AuthContext', () => ({
  useAuth: vi.fn()
}));

// Helper to create a mock realtime client
const mockRealtimeClient = {
  getSessionGeneration: vi.fn().mockReturnValue(1),
  isGenerationValid: vi.fn().mockReturnValue(true)
};

describe('useBuildLogs hook', () => {
  const sampleLogs: BuildLog[] = [
    { id: 'log1', project_id: 'proj1', log_type: 'INFO', message: 'First log', created_at: new Date().toISOString() },
    { id: 'log2', project_id: 'proj1', log_type: 'WARN', message: 'Second log', created_at: new Date().toISOString() }
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    vi.useFakeTimers();
    (getRealtimeClient as any).mockReturnValue(mockRealtimeClient);
    (subscribeBuildLogs as any).mockReturnValue(() => {});
    (useAuth as any).mockReturnValue({ authReady: true, authVersion: 'v1' });
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should initialize with empty logs when projectId is undefined', () => {
    const { result } = renderHook(() => useBuildLogs({ projectId: undefined, onLogAdded: vi.fn() }));
    expect(result.current.logs).toEqual([]);
    expect(result.current.isConnected).toBe(false);
  });

  it('should load logs on mount when projectId and authReady are true', async () => {
    (buildLogService.getBuildLogsByProjectId as any).mockResolvedValue({ data: sampleLogs, error: null });

    const { result, waitForNextUpdate } = renderHook(() =>
      useBuildLogs({ projectId: 'proj1', onLogAdded: vi.fn() })
    );

    // Wait for async refreshLogs to finish
    await waitForNextUpdate();

    expect(buildLogService.getBuildLogsByProjectId).toHaveBeenCalledWith('proj1');
    expect(result.current.logs).toEqual(sampleLogs);
    expect(result.current.isLoading).toBe(false);
  });

  it('should handle error when fetching logs fails', async () => {
    (buildLogService.getBuildLogsByProjectId as any).mockResolvedValue({ data: null, error: new Error('fetch error') });

    const { result, waitForNextUpdate } = renderHook(() =>
      useBuildLogs({ projectId: 'proj1', onLogAdded: vi.fn() })
    );

    await waitForNextUpdate();

    expect(result.current.logs).toEqual([]);
    expect(result.current.isLoading).toBe(false);
  });

  it('should append a new log and call onLogAdded callback', async () => {
    const onLogAddedMock = vi.fn();
    const newLog: BuildLog = { id: 'log3', project_id: 'proj1', log_type: 'ERROR', message: 'Third log', created_at: new Date().toISOString() };

    const { result, waitForNextUpdate } = renderHook(() =>
      useBuildLogs({ projectId: 'proj1', onLogAdded: onLogAddedMock })
    );

    // Ensure initial load completes
    await waitForNextUpdate();

    act(() => {
      result.current.appendLog(newLog);
    });

    expect(result.current.logs).toContainEqual(newLog);
    expect(onLogAddedMock).toHaveBeenCalledWith(newLog);
  });

  test.each([
    ['SUBSCRIBED', true],
    ['RETRYING', false],
    ['CLOSED', false],
    ['CHANNEL_ERROR', false],
    ['TIMED_OUT', false]
  ] as [RealtimeSubscribeStatus, boolean][])(
    'handleStatusChange should set isConnected correctly for status %s',
    async (status, expectedConnected) => {
      const { result, waitForNextUpdate } = renderHook(() =>
        useBuildLogs({ projectId: 'proj1', onLogAdded: vi.fn() })
      );

      // Wait for initial load
      await waitForNextUpdate();

      // Simulate status change
      const handleStatusChange = (result as any).current.handleStatusChange as any;
      handleStatusChange(status, null, { generation: 1 });

      // For SUBSCRIBED, refreshLogs is called after timeout
      if (status === 'SUBSCRIBED') {
        vi.runOnlyPendingTimers();
        await waitForNextUpdate(); // refreshLogs async update
      }

      expect(result.current.isConnected).toBe(expectedConnected);
    }
  );

  it('should refresh logs once when entering an error status from a non-error status', async () => {
    const { result, waitForNextUpdate } = renderHook(() =>
      useBuildLogs({ projectId: 'proj1', onLogAdded: vi.fn() })
    );

    await waitForNextUpdate();

    const handleStatusChange = (result as any).current.handleStatusChange as any;
    // Simulate transition to CLOSED
    handleStatusChange('CLOSED', null, { generation: 1 });

    // refreshLogs should be called again
    await waitForNextUpdate();

    expect(buildLogService.getBuildLogsByProjectId).toHaveBeenCalledTimes(2);
  });

  it('should not refresh logs again if already in error status', async () => {
    const { result, waitForNextUpdate } = renderHook(() =>
      useBuildLogs({ projectId: 'proj1', onLogAdded: vi.fn() })
    );

    await waitForNextUpdate();

    const handleStatusChange = (result as any).current.handleStatusChange as any;
    // First error
    handleStatusChange('CLOSED', null, { generation: 1 });
    await waitForNextUpdate();

    // Second error (same status)
    handleStatusChange('CLOSED', null, { generation: 1 });

    // No additional refreshLogs call
    expect(buildLogService.getBuildLogsByProjectId).toHaveBeenCalledTimes(2);
  });

  it('should cleanup subscription and set isMounted false on unmount', async () => {
    const unsubscribeMock = vi.fn();
    (subscribeBuildLogs as any).mockReturnValue(unsubscribeMock);

    const { unmount, waitForNextUpdate } = renderHook(() =>
      useBuildLogs({ projectId: 'proj1', onLogAdded: vi.fn() })
    );

    await waitForNextUpdate();

    unmount();

    expect(unsubscribeMock).toHaveBeenCalled();
    // After unmount, no further state updates should occur
    const newLog: BuildLog = { id: 'log4', project_id: 'proj1', log_type: 'INFO', message: 'Fourth log', created_at: new Date().toISOString() };
    const handleStatusChange = (result as any).current.handleStatusChange as any;
    handleStatusChange('SUBSCRIBED', null, { generation: 1 });

    // No error should be thrown
    expect(() => handleStatusChange('SUBSCRIBED', null, { generation: 1 })).not.toThrow();
  });

  it('should ignore status changes when component is unmounted', async () => {
    const { unmount, result, waitForNextUpdate } = renderHook(() =>
      useBuildLogs({ projectId: 'proj1', onLogAdded: vi.fn() })
    );

    await waitForNextUpdate();

    unmount();

    const handleStatusChange = (result as any).current.handleStatusChange as any;
    handleStatusChange('SUBSCRIBED', null, { generation: 1 });

    // No state change should happen
    expect(result.current.isConnected).toBe(false);
  });
});