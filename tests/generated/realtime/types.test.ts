// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/types.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import {
  AgentEventType,
  AgentEventPayload,
  AgentEvent,
  AgentState,
  AgentAction,
  FileEventType,
  FileEventPayload,
  FileEvent,
  FileState,
  FileAction,
  TimelineEventType,
  AgentPhase,
  FileUpdateOp,
  BaseTimelineEvent,
  AgentPhaseEvent,
  ToolCallEvent,
  FileUpdateEvent,
  SelfRepairEvent,
  LogEvent,
  ErrorEvent,
  TimelineEvent,
  TimelineState,
  TimelineAction,
  UseTimelineEventsOptions,
  UseTimelineEventsReturn,
  BuildLogEvent,
  BuildLogState,
  BuildLogAction,
  CloseReason,
  StatusChangeMeta,
  StatusChangeCallback,
  RealtimeEvent,
  RealtimeSubscription,
  RealtimeClientConfig,
  RealtimeSubscribeStatus,
  ConnectionStatus,
  DbAgentEvent,
  DbFileEvent,
  SubscribeAgentEventsOptions,
  SubscribeFileEventsOptions,
  SubscribeBuildLogsOptions,
  UseAgentEventsOptions,
  UseAgentEventsReturn,
  UseFileEventsOptions,
  UseFileEventsReturn,
  UseBuildLogsOptions,
  UseBuildLogsReturn,
  RealtimeContextState,
  RealtimeContextValue,
  RealtimeResourceConfig,
  RealtimeResourceState,
  RealtimeResourceReturn,
} from '../../../src/realtime/types';
import { describe, it, expect, test } from 'vitest';

describe('AgentEventType enum', () => {
  const validValues: AgentEventType[] = [
    'task_created',
    'task_started',
    'task_completed',
    'task_failed',
    'message_created',
  ];
  test.each(validValues)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('AgentEventPayload', () => {
  it('should allow required projectId and optional fields', () => {
    const payload: AgentEventPayload = {
      projectId: 'proj-123',
      taskId: 'task-abc',
      messageId: 'msg-xyz',
      status: 'completed',
      result: { key: 'value' },
      error: 'none',
    };
    expect(payload).toEqual(expect.objectContaining({
      projectId: 'proj-123',
      taskId: 'task-abc',
      messageId: 'msg-xyz',
      status: 'completed',
      result: { key: 'value' },
      error: 'none',
    }));
  });

  it('should allow missing optional fields', () => {
    const payload: AgentEventPayload = {
      projectId: 'proj-123',
    };
    expect(payload).toEqual(expect.objectContaining({
      projectId: 'proj-123',
    }));
  });
});

describe('AgentEvent', () => {
  it('should construct an event with type, timestamp, and payload', () => {
    const event: AgentEvent = {
      type: 'task_created',
      timestamp: new Date().toISOString(),
      payload: {
        projectId: 'proj-123',
        taskId: 'task-abc',
      },
    };
    expect(event).toEqual(expect.objectContaining({
      type: 'task_created',
      timestamp: expect.any(String),
      payload: expect.objectContaining({
        projectId: 'proj-123',
        taskId: 'task-abc',
      }),
    }));
  });
});

describe('AgentState', () => {
  it('should have nullable currentTask and messages array', () => {
    const state: AgentState = {
      currentTask: null,
      messages: [],
      isProcessing: false,
      lastError: null,
    };
    expect(state).toEqual(expect.objectContaining({
      currentTask: null,
      messages: expect.any(Array),
      isProcessing: false,
      lastError: null,
    }));
  });
});

describe('AgentAction union', () => {
  const validPayload: ChatMessage = { id: 'msg-1', content: 'hi' };
  test.each([
    { type: 'SET_MESSAGES', payload: [validPayload] },
    { type: 'APPEND_MESSAGE', payload: validPayload },
    { type: 'SET_CURRENT_TASK', payload: null },
    { type: 'TASK_UPDATED', payload: { id: 'task-1', status: 'running' } },
    { type: 'TASK_COMPLETED', payload: { id: 'task-1', status: 'completed' } },
    { type: 'TASK_FAILED', payload: { taskId: 'task-1', error: 'oops' } },
    { type: 'SET_PROCESSING', payload: true },
    { type: 'SET_ERROR', payload: 'error msg' },
  ])('should accept %s type', (action) => {
    expect(action).toEqual(expect.objectContaining({
      type: action.type,
      payload: action.payload,
    }));
  });
});

describe('FileEventType enum', () => {
  const validValues: FileEventType[] = [
    'file_created',
    'file_updated',
    'file_deleted',
  ];
  test.each(validValues)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('FileEventPayload', () => {
  it('should require all fields', () => {
    const payload: FileEventPayload = {
      fileId: 'file-123',
      projectId: 'proj-123',
      filePath: '/src/index.ts',
      fileName: 'index.ts',
    };
    expect(payload).toEqual(expect.objectContaining({
      fileId: 'file-123',
      projectId: 'proj-123',
      filePath: '/src/index.ts',
      fileName: 'index.ts',
    }));
  });
});

describe('FileEvent', () => {
  it('should construct an event with type, timestamp, and payload', () => {
    const event: FileEvent = {
      type: 'file_created',
      timestamp: new Date().toISOString(),
      payload: {
        fileId: 'file-123',
        projectId: 'proj-123',
        filePath: '/src/index.ts',
        fileName: 'index.ts',
      },
    };
    expect(event).toEqual(expect.objectContaining({
      type: 'file_created',
      timestamp: expect.any(String),
      payload: expect.objectContaining({
        fileId: 'file-123',
      }),
    }));
  });
});

describe('FileState', () => {
  it('should have files array and nullable lastUpdated', () => {
    const state: FileState = {
      files: [],
      lastUpdated: null,
    };
    expect(state).toEqual(expect.objectContaining({
      files: expect.any(Array),
      lastUpdated: null,
    }));
  });
});

describe('FileAction union', () => {
  const validFile: ProjectFile = {
    id: 'file-1',
    projectId: 'proj-1',
    path: '/src',
    name: 'file.ts',
    content: 'console.log("hi");',
    version: 'v1',
    type: 'text',
    size: 123,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
  test.each([
    { type: 'SET_FILES', payload: [validFile] },
    { type: 'ADD_FILE', payload: validFile },
    { type: 'UPDATE_FILE', payload: validFile },
    { type: 'REMOVE_FILE', payload: 'file-1' },
  ])('should accept %s type', (action) => {
    expect(action).toEqual(expect.objectContaining({
      type: action.type,
      payload: action.payload,
    }));
  });
});

describe('TimelineEventType enum', () => {
  const validValues: TimelineEventType[] = [
    'agent_phase',
    'tool_call',
    'file_update',
    'self_repair',
    'log',
    'error',
  ];
  test.each(validValues)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('AgentPhase enum', () => {
  const validValues: AgentPhase[] = ['planner', 'coder', 'reviewer', 'debugger'];
  test.each(validValues)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('FileUpdateOp enum', () => {
  const validValues: FileUpdateOp[] = ['create', 'update', 'delete', 'move'];
  test.each(validValues)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('BaseTimelineEvent', () => {
  const base: BaseTimelineEvent = {
    id: 'event-1',
    type: 'log',
    timestamp: new Date().toISOString(),
    taskId: 'task-1',
    projectId: 'proj-1',
  };
  expect(base).toEqual(expect.objectContaining({
    id: 'event-1',
    type: 'log',
    timestamp: expect.any(String),
    taskId: 'task-1',
    projectId: 'proj-1',
  }));
});

describe('AgentPhaseEvent', () => {
  const event: AgentPhaseEvent = {
    id: 'event-2',
    type: 'agent_phase',
    timestamp: new Date().toISOString(),
    taskId: 'task-2',
    projectId: 'proj-2',
    payload: {
      phase: 'coder',
      action: 'enter',
      summary: 'Starting coding phase',
    },
  };
  expect(event).toEqual(expect.objectContaining({
    type: 'agent_phase',
    payload: expect.objectContaining({
      phase: 'coder',
      action: 'enter',
      summary: 'Starting coding phase',
    }),
  }));
});

describe('ToolCallEvent', () => {
  const event: ToolCallEvent = {
    id: 'event-3',
    type: 'tool_call',
    timestamp: new Date().toISOString(),
    taskId: 'task-3',
    projectId: 'proj-3',
    payload: {
      toolName: 'myTool',
      argsSummary: 'arg1, arg2',
      resultSummary: 'success',
      success: true,
      duration: 120,
      fromPath: '/src',
      toPath: '/dist',
    },
  };
  expect(event).toEqual(expect.objectContaining({
    type: 'tool_call',
    payload: expect.objectContaining({
      toolName: 'myTool',
      success: true,
    }),
  }));
});

describe('FileUpdateEvent', () => {
  const event: FileUpdateEvent = {
    id: 'event-4',
    type: 'file_update',
    timestamp: new Date().toISOString(),
    taskId: 'task-4',
    projectId: 'proj-4',
    payload: {
      path: '/src/index.ts',
      op: 'update',
      summary: 'Updated file',
      fileSize: 456,
      mimeType: 'text/plain',
    },
  };
  expect(event).toEqual(expect.objectContaining({
    type: 'file_update',
    payload: expect.objectContaining({
      op: 'update',
    }),
  }));
});

describe('SelfRepairEvent', () => {
  const event: SelfRepairEvent = {
    id: 'event-5',
    type: 'self_repair',
    timestamp: new Date().toISOString(),
    taskId: 'task-5',
    projectId: 'proj-5',
    payload: {
      attemptNumber: 1,
      maxAttempts: 3,
      trigger: 'error',
      errorType: 'TypeError',
      errorMessage: 'undefined is not a function',
      suggestion: 'Check imports',
      result: 'pending',
    },
  };
  expect(event).toEqual(expect.objectContaining({
    type: 'self_repair',
    payload: expect.objectContaining({
      attemptNumber: 1,
      result: 'pending',
    }),
  }));
});

describe('LogEvent', () => {
  const event: LogEvent = {
    id: 'event-6',
    type: 'log',
    timestamp: new Date().toISOString(),
    taskId: 'task-6',
    projectId: 'proj-6',
    payload: {
      level: 'info',
      message: 'All good',
      metadata: { key: 'value' },
    },
  };
  expect(event).toEqual(expect.objectContaining({
    type: 'log',
    payload: expect.objectContaining({
      level: 'info',
      message: 'All good',
    }),
  }));
});

describe('ErrorEvent', () => {
  const event: ErrorEvent = {
    id: 'event-7',
    type: 'error',
    timestamp: new Date().toISOString(),
    taskId: 'task-7',
    projectId: 'proj-7',
    payload: {
      errorType: 'NetworkError',
      message: 'Failed to fetch',
      stack: 'stack trace',
      recoverable: false,
    },
  };
  expect(event).toEqual(expect.objectContaining({
    type: 'error',
    payload: expect.objectContaining({
      errorType: 'NetworkError',
      recoverable: false,
    }),
  }));
});

describe('TimelineEvent discriminated union', () => {
  const events: TimelineEvent[] = [
    {
      id: 'e1',
      type: 'agent_phase',
      timestamp: new Date().toISOString(),
      taskId: 't1',
      projectId: 'p1',
      payload: { phase: 'planner', action: 'enter' },
    },
    {
      id: 'e2',
      type: 'tool_call',
      timestamp: new Date().toISOString(),
      taskId: 't2',
      projectId: 'p2',
      payload: { toolName: 'tool', success: true },
    },
    {
      id: 'e3',
      type: 'log',
      timestamp: new Date().toISOString(),
      taskId: 't3',
      projectId: 'p3',
      payload: { level: 'debug', message: 'debugging' },
    },
  ];
  events.forEach((e) => {
    expect(e).toHaveProperty('type');
    expect(e).toHaveProperty('payload');
  });
});

describe('TimelineState', () => {
  const state: TimelineState = {
    events: [],
    phases: [],
    tools: [],
    files: [],
    repairs: [],
    logs: [],
    errors: [],
    currentPhase: null,
  };
  expect(state).toEqual(expect.objectContaining({
    events: expect.any(Array),
    currentPhase: null,
  }));
});

describe('TimelineAction union', () => {
  const action: TimelineAction = {
    type: 'ADD_EVENT',
    payload: {
      id: 'e4',
      type: 'error',
      timestamp: new Date().toISOString(),
      taskId: 't4',
      projectId: 'p4',
      payload: { errorType: 'Error', message: 'oops', recoverable: true },
    },
  };
  expect(action).toEqual(expect.objectContaining({
    type: 'ADD_EVENT',
    payload: expect.objectContaining({
      type: 'error',
    }),
  }));
});

describe('UseTimelineEventsOptions', () => {
  const options: UseTimelineEventsOptions = {
    projectId: 'proj-99',
    taskId: 'task-99',
    maxEvents: 50,
  };
  expect(options).toEqual(expect.objectContaining({
    projectId: 'proj-99',
    maxEvents: 50,
  }));
});

describe('UseTimelineEventsReturn', () => {
  const ret: UseTimelineEventsReturn = {
    events: [],
    phases: [],
    tools: [],
    files: [],
    repairs: [],
    logs: [],
    errors: [],
    currentPhase: null,
    isConnected: true,
    addEvent: () => {},
    clearEvents: () => {},
  };
  expect(ret).toEqual(expect.objectContaining({
    isConnected: true,
    currentPhase: null,
  }));
});

describe('BuildLogEvent', () => {
  const event: BuildLogEvent = {
    type: 'log_created',
    timestamp: new Date().toISOString(),
    payload: { id: 'log-1', message: 'build started', level: 'info' },
  };
  expect(event).toEqual(expect.objectContaining({
    type: 'log_created',
    payload: expect.objectContaining({
      id: 'log-1',
    }),
  }));
});

describe('BuildLogState', () => {
  const state: BuildLogState = {
    logs: [],
  };
  expect(state).toEqual(expect.objectContaining({
    logs: expect.any(Array),
  }));
});

describe('BuildLogAction union', () => {
  const action1: BuildLogAction = {
    type: 'SET_LOGS',
    payload: [{ id: 'log-2', message: 'done', level: 'info' }],
  };
  const action2: BuildLogAction = {
    type: 'APPEND_LOG',
    payload: { id: 'log-3', message: 'appended', level: 'debug' },
  };
  const action3: BuildLogAction = {
    type: 'CLEAR_LOGS',
    payload: undefined,
  };
  [action1, action2, action3].forEach((a) => {
    expect(a).toEqual(expect.objectContaining({
      type: a.type,
    }));
  });
});

describe('CloseReason enum', () => {
  const values: CloseReason[] = [
    'CLEANUP',
    'UNSUBSCRIBE',
    'ERROR',
    'AUTH_CHANGE',
    'UNKNOWN',
  ];
  test.each(values)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('StatusChangeMeta', () => {
  const meta: StatusChangeMeta = {
    generation: 1,
    closeReason: 'ERROR',
    channelName: 'chan-1',
    isExpectedClose: false,
  };
  expect(meta).toEqual(expect.objectContaining({
    generation: 1,
    closeReason: 'ERROR',
    channelName: 'chan-1',
    isExpectedClose: false,
  }));
});

describe('StatusChangeCallback', () => {
  const callback: StatusChangeCallback = (
    status,
    error,
    meta,
  ) => {
    // simple implementation for test
    if (status) {
      console.log('status', status);
    }
    if (error) {
      console.error('error', error);
    }
    if (meta) {
      console.log('meta', meta);
    }
  };
  expect(callback).toBeInstanceOf(Function);
});

describe('RealtimeEvent enum', () => {
  const values: RealtimeEvent[] = ['INSERT', 'UPDATE', 'DELETE'];
  test.each(values)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('RealtimeSubscription', () => {
  const sub: RealtimeSubscription = {
    channelName: 'chan-1',
    table: 'agents',
    event: 'INSERT',
    filter: 'id=eq.1',
    unsubscribe: () => {},
  };
  expect(sub).toEqual(expect.objectContaining({
    channelName: 'chan-1',
    event: 'INSERT',
    unsubscribe: expect.any(Function),
  }));
});

describe('RealtimeClientConfig', () => {
  const cfg: RealtimeClientConfig = {
    onConnectionChange: (c) => console.log(c),
    onError: (e) => console.error(e),
    onChannelFailure: ({ channelName, table, event, error }) => {
      console.log(channelName, table, event, error);
    },
  };
  expect(cfg).toEqual(expect.objectContaining({
    onConnectionChange: expect.any(Function),
    onError: expect.any(Function),
    onChannelFailure: expect.any(Function),
  }));
});

describe('RealtimeSubscribeStatus enum', () => {
  const values: RealtimeSubscribeStatus[] = [
    'SUBSCRIBED',
    'CLOSED',
    'CHANNEL_ERROR',
    'RETRYING',
    'TIMED_OUT',
    'UNKNOWN',
  ];
  test.each(values)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('ConnectionStatus enum', () => {
  const values: ConnectionStatus[] = ['disconnected', 'connecting', 'connected', 'error'];
  test.each(values)('should accept %s', (value) => {
    expect(value).toBe(value);
  });
});

describe('DbAgentEvent', () => {
  const event: DbAgentEvent = {
    id: 'da-1',
    task_id: null,
    project_id: 'proj-1',
    type: 'agent_phase',
    payload: { phase: 'planner' },
    created_at: new Date().toISOString(),
  };
  expect(event).toEqual(expect.objectContaining({
    id: 'da-1',
    type: 'agent_phase',
    created_at: expect.any(String),
  }));
});

describe('DbFileEvent', () => {
  const event: DbFileEvent = {
    id: 'df-1',
    project_id: 'proj-1',
    path: '/src',
    op: 'create',
    summary: 'created',
    content_ref: null,
    version: null,
    from_path: null,
    created_at: new Date().toISOString(),
  };
  expect(event).toEqual(expect.objectContaining({
    id: 'df-1',
    op: 'create',
    created_at: expect.any(String),
  }));
});

describe('SubscribeAgentEventsOptions', () => {
  const opts: SubscribeAgentEventsOptions = {
    projectId: 'proj-2',
    onTaskUpdate: (t) => console.log(t),
    onMessageCreated: (m) => console.log(m),
    onAgentEvent: (e) => console.log(e),
    onError: (e) => console.error(e),
    onStatusChange: (s, e, m) => console.log(s, e, m),
  };
  expect(opts).toEqual(expect.objectContaining({
    projectId: 'proj-2',
    onTaskUpdate: expect.any(Function),
  }));
});

describe('SubscribeFileEventsOptions', () => {
  const opts: SubscribeFileEventsOptions = {
    projectId: 'proj-3',
    versionId: 'v1',
    onFileCreated: (f) => console.log(f),
    onFileUpdated: (f) => console.log(f),
    onFileDeleted: (id) => console.log(id),
    onFileEvent: (e) => console.log(e),
    onError: (e) => console.error(e),
    onStatusChange: (s, e, m) => console.log(s, e, m),
  };
  expect(opts).toEqual(expect.objectContaining({
    projectId: 'proj-3',
    onFileDeleted: expect.any(Function),
  }));
});

describe('SubscribeBuildLogsOptions', () => {
  const opts: SubscribeBuildLogsOptions = {
    projectId: 'proj-4',
    onLogCreated: (l) => console.log(l),
    onError: (e) => console.error(e),
    onStatusChange: (s, e, m) => console.log(s, e, m),
  };
  expect(opts).toEqual(expect.objectContaining({
    projectId: 'proj-4',
    onLogCreated: expect.any(Function),
  }));
});

describe('UseAgentEventsOptions', () => {
  const opts: UseAgentEventsOptions = {
    projectId: undefined,
    onTaskCompleted: (t) => console.log(t),
    onMessageReceived: (m) => console.log(m),
  };
  expect(opts).toEqual(expect.objectContaining({
    projectId: undefined,
    onMessageReceived: expect.any(Function),
  }));
});

describe('UseAgentEventsReturn', () => {
  const ret: UseAgentEventsReturn = {
    messages: [],
    currentTask: null,
    isProcessing: false,
    isConnected: true,
    lastError: null,
    appendMessage: (m) => {},
    refreshMessages: async () => {},
    messageImages: {},
    imageBlobUrls: {},
  };
  expect(ret).toEqual(expect.objectContaining({
    isConnected: true,
    currentTask: null,
  }));
});

describe('UseFileEventsOptions', () => {
  const opts: UseFileEventsOptions = {
    projectId: 'proj-5',
    versionId: 'v2',
  };
  expect(opts).toEqual(expect.objectContaining({
    projectId: 'proj-5',
    versionId: 'v2',
  }));
});

describe('UseFileEventsReturn', () => {
  const ret: UseFileEventsReturn = {
    files: [],
    isLoading: false,
    isConnected: true,
    refreshFiles: async () => {},
  };
  expect(ret).toEqual(expect.objectContaining({
    isConnected: true,
    isLoading: false,
  }));
});

describe('UseBuildLogsOptions', () => {
  const opts: UseBuildLogsOptions = {
    projectId: 'proj-6',
    onLogAdded: (l) => console.log(l),
  };
  expect(opts).toEqual(expect.objectContaining({
    projectId: 'proj-6',
    onLogAdded: expect.any(Function),
  }));
});

describe('UseBuildLogsReturn', () => {
  const ret: UseBuildLogsReturn = {
    logs: [],
    isLoading: false,
    isConnected: true,
    appendLog: (l) => {},
    refreshLogs: async () => {},
  };
  expect(ret).toEqual(expect.objectContaining({
    isConnected: true,
    isLoading: false,
  }));
});

describe('RealtimeContextState', () => {
  const state: RealtimeContextState = {
    sessionGeneration: 1,
    connectionStatus: 'connected',
    authReady: true,
    authVersion: 2,
    isExpectedClose: false,
  };
  expect(state).toEqual(expect.objectContaining({
    sessionGeneration: 1,
    connectionStatus: 'connected',
  }));
});

describe('RealtimeContextValue', () => {
  const value: RealtimeContextValue = {
    sessionGeneration: 1,
    connectionStatus: 'connected',
    authReady: true,
    authVersion: 2,
    isExpectedClose: false,
    incrementGeneration: () => 2,
    markExpectedClose: () => {},
    clearExpectedClose: () => {},
    isGenerationValid: (g) => g === 1,
    getCurrentGeneration: () => 1,
  };
  expect(value).toEqual(expect.objectContaining({
    connectionStatus: 'connected',
    incrementGeneration: expect.any(Function),
  }));
});

describe('RealtimeResourceConfig generic', () => {
  const config: RealtimeResourceConfig<BuildLog> = {
    resourceKey: 'build-log',
    projectId: 'proj-7',
    fetchSnapshot: async () => [{ id: 'log-1', message: 'msg', level: 'info' }],
    subscribeIncrements: (handlers) => {
      handlers.onInsert?.({ id: 'log-2', message: 'msg2', level: 'debug' });
      return () => {};
    },
    getItemId: (item) => item.id,
    enabled: true,
    refreshThrottleMs: 500,
    deps: [],
  };
  expect(config).toEqual(expect.objectContaining({
    resourceKey: 'build-log',
    projectId: 'proj-7',
  }));
});

describe('RealtimeResourceState generic', () => {
  const state: RealtimeResourceState<BuildLog> = {
    data: [{ id: 'log-3', message: 'msg3', level: 'info' }],
    isLoading: false,
    isConnected: true,
    error: null,
    generation: 1,
  };
  expect(state).toEqual(expect.objectContaining({
    isConnected: true,
    data: expect.any(Array),
  }));
});

describe('RealtimeResourceReturn generic', () => {
  const ret: RealtimeResourceReturn<BuildLog> = {
    data: [],
    isLoading: false,
    isConnected: true,
    error: null,
    generation: 1,
    refresh: async () => {},
    appendItem: (item) => {},
    updateItem: (item) => {},
    removeItem: (id) => {},
    setData: (data) => {},
  };
  expect(ret).toEqual(expect.objectContaining({
    isConnected: true,
    data: expect.any(Array),
  }));
});