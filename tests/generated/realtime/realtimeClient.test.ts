// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/realtimeClient.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { getRealtimeClient, subscribeToTable, cleanupRealtime, isRealtimeConnected } from '../../../src/realtime/realtimeClient';
import type { RealtimeChannel } from '@supabase/supabase-js';

// Mock the supabase module
vi.mock('../../../src/lib/supabase', () => {
  const mockChannel = (topic: string) => {
    const callbacks: any[] = [];
    const on = (_type: string, _config: any, cb: (payload: any) => void) => {
      callbacks.push(cb);
    };
    const subscribe = (statusCallback: (statusOrObj: string | any) => void) => {
      // Store the status callback to be invoked manually in tests
      callbacks.push(statusCallback);
    };
    return {
      topic,
      state: 'connected',
      on,
      subscribe,
    };
  };

  const mockSupabase = {
    channel: vi.fn((topic: string) => mockChannel(topic)),
    getChannels: vi.fn(() => []),
    removeChannel: vi.fn(),
  };

  const mockRefreshRealtimeAuth = vi.fn(() => Promise.resolve());

  return {
    supabase: mockSupabase,
    refreshRealtimeAuth: mockRefreshRealtimeAuth,
  };
});

import { supabase, refreshRealtimeAuth } from '../../../src/lib/supabase';

describe('RealtimeClient', () => {
  beforeEach(() => {
    // Reset singleton before each test
    const { resetInstance } = await import('../../../src/realtime/realtimeClient');
    resetInstance();

    // Mock global window to simulate browser environment
    globalThis.window = {};

    // Clear mocks
    vi.clearAllMocks();
    vi.stubGlobal('console', {
      log: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
    });
  });

  afterEach(() => {
    // Clean up global window
    delete globalThis.window;
  });

  it('should initialize correctly and set connection status to connecting', () => {
    const client = getRealtimeClient();
    client.initialize({ onConnectionChange: vi.fn() });

    expect(client.getConnectionStatus()).toBe('connecting');
    expect(supabase.channel).not.toHaveBeenCalled();
  });

  it('should warn and return when window is undefined', () => {
    delete globalThis.window;
    const client = getRealtimeClient();
    client.initialize();

    expect(console.warn).toHaveBeenCalledWith(
      '[RealtimeClient] 只能在浏览器环境中初始化'
    );
  });

  it('should return correct connection status and isConnected flag', () => {
    const client = getRealtimeClient();
    client.initialize();

    // Simulate channel subscribe callback with SUBSCRIBED
    const channel = supabase.channel.mock.results[0].value;
    channel.subscribe((statusOrObj) => {
      if (typeof statusOrObj === 'string') {
        channel.state = statusOrObj;
      }
    });

    expect(client.getConnectionStatus()).toBe('connected');
    expect(client.isConnected()).toBe(true);
  });

  it('should manage session generation correctly', () => {
    const client = getRealtimeClient();
    client.initialize();

    const gen1 = client.getSessionGeneration();
    client.incrementGeneration();
    const gen2 = client.getSessionGeneration();

    expect(gen1).toBe(0);
    expect(gen2).toBe(1);
    expect(client.isGenerationValid(gen1)).toBe(false);
    expect(client.isGenerationValid(gen2)).toBe(true);
  });

  it('should mark and clear expected close correctly', () => {
    const client = getRealtimeClient();
    client.initialize();

    client.markExpectedClose('AUTH_EXPIRED');
    // Access private fields via type assertion for test
    expect((client as any).isExpectedClose).toBe(true);
    expect((client as any).currentCloseReason).toBe('AUTH_EXPIRED');

    client.clearExpectedClose();
    expect((client as any).isExpectedClose).toBe(false);
    expect((client as any).currentCloseReason).toBe('UNKNOWN');
  });

  describe('subscribeToTable', () => {
    const channelName = 'test_channel';
    const table = 'users';
    const event = 'INSERT' as const;
    const filter = 'id=eq.1';

    const createSubscription = async (
      filter?: string
    ): Promise<{
      unsubscribe: () => void;
      onStatusChange: vi.Mock;
      callback: vi.Mock;
    }> => {
      const callback = vi.fn();
      const onStatusChange = vi.fn();
      const unsubscribe = subscribeToTable(
        channelName,
        table,
        event,
        filter,
        callback,
        onStatusChange
      );
      // Wait for async setup to finish
      await Promise.resolve();
      return { unsubscribe, onStatusChange, callback };
    };

    it.each`
      filter
      ${undefined}
      ${'id=eq.1'}
    `('should create a subscription and call onStatusChange on SUBSCRIBED (filter=$filter)', async ({ filter }) => {
      const { unsubscribe, onStatusChange } = await createSubscription(filter);

      // Retrieve the mock channel
      const channelKey = filter
        ? `${channelName}-${(supabase.channel as any).mock.calls[0][0]}::${filter}`
        : `${channelName}-${(supabase.channel as any).mock.calls[0][0]}`;
      const channel = supabase.channel.mock.results[0].value;

      // Simulate channel subscribe callback with SUBSCRIBED
      channel.subscribe((statusOrObj) => {
        if (typeof statusOrObj === 'string') {
          channel.state = statusOrObj;
        }
      });

      // Invoke the stored status callback manually
      const statusCallback = channel.subscribe.mock.calls[0][0];
      statusCallback('SUBSCRIBED');

      expect(onStatusChange).toHaveBeenCalledWith(
        'SUBSCRIBED',
        null,
        expect.objectContaining({
          generation: expect.any(Number),
          channelName: channelKey,
          isExpectedClose: false,
        })
      );

      // Cleanup
      unsubscribe();
    });

    it('should call onStatusChange with CLOSED and error when channel closes', async () => {
      const { unsubscribe, onStatusChange } = await createSubscription();

      const channel = supabase.channel.mock.results[0].value;

      // Simulate channel subscribe callback with CLOSED
      channel.subscribe((statusOrObj) => {
        if (typeof statusOrObj === 'string') {
          channel.state = statusOrObj;
        }
      });

      const statusCallback = channel.subscribe.mock.calls[0][0];
      const error = new Error('Network error');
      statusCallback({ status: 'CLOSED', error });

      expect(onStatusChange).toHaveBeenCalledWith(
        'CLOSED',
        error,
        expect.objectContaining({
          generation: expect.any(Number),
          channelName: expect.any(String),
          closeReason: expect.any(String),
          isExpectedClose: false,
        })
      );

      // Cleanup
      unsubscribe();
    });

    it('should not initialize if window is undefined and return empty unsubscribe', () => {
      delete globalThis.window;
      const unsubscribe = subscribeToTable(
        channelName,
        table,
        event,
        undefined,
        vi.fn(),
        vi.fn()
      );

      expect(unsubscribe).toBeInstanceOf(Function);
      // No channel should be created
      expect(supabase.channel).not.toHaveBeenCalled();
    });
  });

  describe('cleanup', () => {
    it('should clear all channels, subscriptions, and increment generation', async () => {
      const client = getRealtimeClient();
      client.initialize();

      // Create a subscription
      const callback = vi.fn();
      const onStatusChange = vi.fn();
      const unsubscribe = subscribeToTable(
        'cleanup_channel',
        'orders',
        'UPDATE',
        undefined,
        callback,
        onStatusChange
      );
      await Promise.resolve();

      // Simulate channel subscribe callback with SUBSCRIBED
      const channel = supabase.channel.mock.results[0].value;
      channel.subscribe((statusOrObj) => {
        if (typeof statusOrObj === 'string') {
          channel.state = statusOrObj;
        }
      });
      const statusCallback = channel.subscribe.mock.calls[0][0];
      statusCallback('SUBSCRIBED');

      // Perform cleanup
      cleanupRealtime('CLEANUP');

      // Verify internal state
      expect(client.getConnectionStatus()).toBe('disconnected');
      expect(client.isConnected()).toBe(false);
      expect(client.getSessionGeneration()).toBe(1); // incremented once
      expect(client['channels'].size).toBe(0);
      expect(client['subscriptions'].size).toBe(0);
      expect(supabase.removeChannel).toHaveBeenCalledTimes(1);
    });
  });

  describe('isRealtimeConnected', () => {
    it('should reflect client connection status', () => {
      const client = getRealtimeClient();
      client.initialize();

      // Initially not connected
      expect(isRealtimeConnected()).toBe(false);

      // Simulate SUBSCRIBED
      const channel = supabase.channel.mock.results[0].value;
      channel.subscribe((statusOrObj) => {
        if (typeof statusOrObj === 'string') {
          channel.state = statusOrObj;
        }
      });
      const statusCallback = channel.subscribe.mock.calls[0][0];
      statusCallback('SUBSCRIBED');

      expect(isRealtimeConnected()).toBe(true);
    });
  });
});