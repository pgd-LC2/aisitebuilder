// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/subscribeAgentEvents.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, vi, beforeEach } from 'vitest';
import subscribeAgentEvents from '../../../src/realtime/subscribeAgentEvents';
import type { AITask, ChatMessage, DbAgentEvent } from '../../../src/types/project';
import type { SubscribeAgentEventsOptions } from '../../../src/realtime/types';

vi.mock('../../../src/realtime/realtimeClient', () => ({
  subscribeToTable: vi.fn()
}));

import { subscribeToTable } from '../../../src/realtime/realtimeClient';

describe('subscribeAgentEvents', () => {
  const consoleWarnMock = vi.fn();
  const consoleLogMock = vi.fn();
  const consoleErrorMock = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    console.warn = consoleWarnMock;
    console.log = consoleLogMock;
    console.error = consoleErrorMock;
  });

  it('should warn and return no-op when projectId is falsy', () => {
    const cancel = subscribeAgentEvents({
      projectId: '',
      onTaskUpdate: vi.fn(),
      onMessageCreated: vi.fn(),
      onAgentEvent: vi.fn(),
      onError: vi.fn(),
      onStatusChange: vi.fn()
    });

    expect(consoleWarnMock).toHaveBeenCalledWith(
      '[subscribeAgentEvents] projectId 为空，跳过订阅'
    );
    expect(typeof cancel).toBe('function');
    expect(cancel()).toBeUndefined();
    expect(subscribeToTable).not.toHaveBeenCalled();
  });

  test.each([
    {
      name: 'AI task update',
      optionKey: 'onTaskUpdate',
      tableName: 'agent-tasks-123',
      schema: 'ai_tasks',
      eventType: 'UPDATE',
      filter: 'project_id=eq.123',
      mockPayload: { id: 'task1', status: 'completed' } as AITask
    },
    {
      name: 'New chat message',
      optionKey: 'onMessageCreated',
      tableName: 'agent-messages-123',
      schema: 'chat_messages',
      eventType: 'INSERT',
      filter: 'project_id=eq.123',
      mockPayload: { id: 'msg1', role: 'assistant' } as ChatMessage
    },
    {
      name: 'Agent event',
      optionKey: 'onAgentEvent',
      tableName: 'agent-events-123',
      schema: 'agent_events',
      eventType: 'INSERT',
      filter: 'project_id=eq.123',
      mockPayload: { id: 'ev1', type: 'START' } as DbAgentEvent
    }
  ] as const)('$name', ({ optionKey, tableName, schema, eventType, filter, mockPayload }) => {
    const mockCallback = vi.fn();
    const mockStatusChange = vi.fn();

    const unsubMock = vi.fn();
    subscribeToTable.mockImplementationOnce(() => unsubMock);

    const options: SubscribeAgentEventsOptions = {
      projectId: '123',
      onStatusChange: mockStatusChange
    } as any;
    (options as any)[optionKey] = mockCallback;

    const cancel = subscribeAgentEvents(options);

    expect(subscribeToTable).toHaveBeenCalledWith(
      tableName,
      schema,
      eventType,
      filter,
      expect.any(Function),
      mockStatusChange
    );

    // Simulate receiving a row
    const callback = (subscribeToTable as any).mock.calls[0][4];
    callback(mockPayload);

    expect(mockCallback).toHaveBeenCalledWith(mockPayload);
    expect(consoleLogMock).toHaveBeenCalledWith(
      `[subscribeAgentEvents] 收到${optionKey.split('on')[0].toLowerCase()}:`,
      mockPayload.id,
      (mockPayload as any).status ?? (mockPayload as any).role ?? (mockPayload as any).type
    );

    // Verify cancel unsubscribes
    cancel();
    expect(unsubMock).toHaveBeenCalled();
  });

  it('should handle errors during subscription and call onError', () => {
    const error = new Error('subscription failed');
    const mockErrorHandler = vi.fn();
    const mockStatusChange = vi.fn();

    subscribeToTable.mockImplementationOnce(() => {
      throw error;
    });

    const cancel = subscribeAgentEvents({
      projectId: '123',
      onError: mockErrorHandler,
      onStatusChange: mockStatusChange
    });

    expect(consoleErrorMock).toHaveBeenCalledWith(
      '[subscribeAgentEvents] 订阅失败:',
      error
    );
    expect(mockErrorHandler).toHaveBeenCalledWith(error);
    expect(typeof cancel).toBe('function');
    expect(cancel()).toBeUndefined();
  });

  it('should pass onStatusChange to each subscription', () => {
    const mockStatusChange = vi.fn();

    const unsubMocks = [vi.fn(), vi.fn(), vi.fn()];
    subscribeToTable.mockImplementationOnce(() => unsubMocks[0])
      .mockImplementationOnce(() => unsubMocks[1])
      .mockImplementationOnce(() => unsubMocks[2]);

    const cancel = subscribeAgentEvents({
      projectId: '123',
      onTaskUpdate: vi.fn(),
      onMessageCreated: vi.fn(),
      onAgentEvent: vi.fn(),
      onStatusChange: mockStatusChange
    });

    expect(subscribeToTable).toHaveBeenCalledTimes(3);
    subscribeToTable.mock.calls.forEach((call: any) => {
      expect(call[5]).toBe(mockStatusChange);
    });

    cancel();
    unsubMocks.forEach(unsub => expect(unsub).toHaveBeenCalled());
  });

  it('should handle edge case projectIds with special characters and large values', () => {
    const specialProjectId = '!@#$%^&*()_+-=[]{}|;:\'",.<>/?`~';
    const largeProjectId = 'p'.repeat(1000);

    const mockCallback = vi.fn();
    const unsubMock = vi.fn();

    // Test special characters
    subscribeToTable.mockImplementationOnce(() => unsubMock);
    subscribeAgentEvents({
      projectId: specialProjectId,
      onTaskUpdate: mockCallback
    });

    expect(subscribeToTable).toHaveBeenCalledWith(
      `agent-tasks-${specialProjectId}`,
      'ai_tasks',
      'UPDATE',
      `project_id=eq.${specialProjectId}`,
      expect.any(Function),
      undefined
    );

    // Test large projectId
    subscribeToTable.mockImplementationOnce(() => unsubMock);
    subscribeAgentEvents({
      projectId: largeProjectId,
      onMessageCreated: mockCallback
    });

    expect(subscribeToTable).toHaveBeenCalledWith(
      `agent-messages-${largeProjectId}`,
      'chat_messages',
      'INSERT',
      `project_id=eq.${largeProjectId}`,
      expect.any(Function),
      undefined
    );
  });
});