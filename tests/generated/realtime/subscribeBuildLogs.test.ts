// AUTO-GENERATED BY generate-tests.ts
// Source: src/realtime/subscribeBuildLogs.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, vi, test } from 'vitest';
import { subscribeBuildLogs } from '../../../src/realtime/subscribeBuildLogs';
import type { BuildLog } from '../../../src/types/project';
import type { SubscribeBuildLogsOptions } from '../../../src/realtime/types';

// Mock the realtimeClient module
vi.mock('../../../src/realtime/realtimeClient', () => ({
  subscribeToTable: vi.fn(),
}));

const { subscribeToTable } = await import('../../../src/realtime/realtimeClient');

describe('subscribeBuildLogs', () => {
  const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
  const consoleLogSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
  const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('should return a no-op function and warn when projectId is falsy', () => {
    const onLogCreated = vi.fn();
    const onError = vi.fn();
    const onStatusChange = vi.fn();

    const unsubscribe = subscribeBuildLogs({
      projectId: '',
      onLogCreated,
      onError,
      onStatusChange,
    });

    expect(consoleWarnSpy).toHaveBeenCalledWith(
      '[subscribeBuildLogs] projectId 为空，跳过订阅'
    );
    expect(subscribeToTable).not.toHaveBeenCalled();
    expect(unsubscribe).toBeInstanceOf(Function);

    // invoking the returned function should do nothing
    unsubscribe();
  });

  test.each([
    { projectId: 'proj-1', description: 'normal string' },
    { projectId: '12345678901234567890', description: 'very large numeric string' },
    { projectId: 'proj_特殊字符', description: 'string with special characters' },
  ])('should subscribe successfully for $description', ({ projectId }) => {
    const onLogCreated = vi.fn();
    const onStatusChange = vi.fn();

    // Capture the callback passed to subscribeToTable
    let logCallback: (log: BuildLog) => void;
    const mockUnsubscribe = vi.fn();
    (subscribeToTable as vi.Mock).mockImplementation(
      (_tableName, _schema, _event, _filter, callback, statusChange) => {
        logCallback = callback;
        expect(statusChange).toBe(onStatusChange);
        return mockUnsubscribe;
      }
    );

    const unsubscribe = subscribeBuildLogs({
      projectId,
      onLogCreated,
      onStatusChange,
    });

    // Verify subscribeToTable was called with correct parameters
    expect(subscribeToTable).toHaveBeenCalledWith(
      `build-logs-${projectId}`,
      'build_logs',
      'INSERT',
      `project_id=eq.${projectId}`,
      expect.any(Function),
      onStatusChange
    );

    // Simulate a log event
    const fakeLog: BuildLog = {
      id: 'log-123',
      log_type: 'INFO',
      message: 'Build started',
      timestamp: new Date().toISOString(),
      project_id: projectId,
    };
    logCallback(fakeLog);

    expect(onLogCreated).toHaveBeenCalledWith(fakeLog);

    // Verify unsubscribe function works
    const returnedUnsubscribe = unsubscribe();
    expect(mockUnsubscribe).toHaveBeenCalled();
    expect(returnedUnsubscribe).toBeInstanceOf(Function);
    returnedUnsubscribe(); // should call the original unsubscribe
    expect(mockUnsubscribe).toHaveBeenCalledTimes(2);
  });

  it('should handle errors thrown by subscribeToTable and call onError', () => {
    const error = new Error('Subscription failed');
    (subscribeToTable as vi.Mock).mockImplementation(() => {
      throw error;
    });

    const onError = vi.fn();

    const unsubscribe = subscribeBuildLogs({
      projectId: 'proj-2',
      onError,
    });

    expect(consoleErrorSpy).toHaveBeenCalledWith(
      '[subscribeBuildLogs] 订阅失败:',
      error
    );
    expect(onError).toHaveBeenCalledWith(error);
    expect(subscribeToTable).toHaveBeenCalled();

    // The returned function should be a no-op
    const returnedUnsubscribe = unsubscribe();
    expect(returnedUnsubscribe).toBeInstanceOf(Function);
    returnedUnsubscribe(); // no effect
  });

  it('should not call subscribeToTable when projectId is null or undefined', () => {
    const unsubscribeNull = subscribeBuildLogs({
      projectId: null as any,
    });
    const unsubscribeUndefined = subscribeBuildLogs({
      projectId: undefined as any,
    });

    expect(subscribeToTable).not.toHaveBeenCalled();
    expect(consoleWarnSpy).toHaveBeenCalledTimes(2);
    unsubscribeNull();
    unsubscribeUndefined();
  });
});