// AUTO-GENERATED BY generate-tests.ts
// Source: src/contexts/ProjectContext.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { render, screen, waitFor } from '@testing-library/react';
import { vi, describe, it, expect, test } from 'vitest';
import { ProjectProvider, useProject } from '../../../src/contexts/ProjectContext';
import { Project } from '../../../src/types/project';
import { projectService } from '../../../src/services/projectService';
import { useAuth } from '../../../src/contexts/AuthContext';
import { ReactNode } from 'react';

// Mock external dependencies
vi.mock('../../../src/services/projectService', () => ({
  projectService: {
    getProjectsByUserId: vi.fn(),
    createProject: vi.fn(),
    updateProjectStatus: vi.fn(),
    deleteProject: vi.fn(),
  },
}));

vi.mock('../../../src/contexts/AuthContext', () => ({
  useAuth: vi.fn(),
}));

// Helper component to consume context
function TestComponent({ children }: { children: ReactNode }) {
  const ctx = useProject();
  return <div data-testid="context">{JSON.stringify(ctx)}</div>;
}

describe('ProjectProvider', () => {
  const mockUser = { id: 'user-123' };
  const mockProjects: Project[] = [
    { id: 'p1', title: 'Project 1', description: 'Desc 1', status: 'active' },
    { id: 'p2', title: 'Project 2', description: 'Desc 2', status: 'archived' },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should initialize with loading true and refresh projects on mount', async () => {
    (useAuth as any).mockReturnValue({ user: mockUser });
    (projectService.getProjectsByUserId as any).mockResolvedValue({
      data: mockProjects,
      error: null,
    });

    render(<ProjectProvider><TestComponent /></ProjectProvider>);

    // Loading should be true initially
    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      expect(ctx.loading).toBe(true);
    });

    // After refresh, loading false and projects set
    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      expect(ctx.loading).toBe(false);
      expect(ctx.projects).toEqual(mockProjects);
    });
  });

  it('should set projects empty and loading false when user is null', async () => {
    (useAuth as any).mockReturnValue({ user: null });

    render(<ProjectProvider><TestComponent /></ProjectProvider>);

    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      expect(ctx.projects).toEqual([]);
      expect(ctx.loading).toBe(false);
    });
  });

  it('should create a project successfully', async () => {
    const newProject: Project = {
      id: 'p3',
      title: 'New Project',
      description: 'New Desc',
      status: 'active',
    };
    (useAuth as any).mockReturnValue({ user: mockUser });
    (projectService.createProject as any).mockResolvedValue({
      data: newProject,
      error: null,
    });

    render(<ProjectProvider><TestComponent /></ProjectProvider>);

    // Trigger createProject via context
    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      return ctx.createProject('New Project', 'New Desc');
    });

    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      expect(ctx.projects[0]).toEqual(newProject);
      expect(ctx.currentProject).toEqual(newProject);
    });
  });

  it('should handle createProject failure when user not authenticated', async () => {
    (useAuth as any).mockReturnValue({ user: null });

    render(<ProjectProvider><TestComponent /></ProjectProvider>);

    const ctxDiv = screen.getByTestId('context');
    const ctx = JSON.parse(ctxDiv.textContent ?? '{}');

    const result = await ctx.createProject('Title', 'Desc');
    expect(result.error).toBeInstanceOf(Error);
    expect(result.error.message).toBe('User not authenticated');
    expect(result.data).toBeNull();
  });

  it('should update project status and keep currentProject sync', async () => {
    const updatedProject: Project = { ...mockProjects[0], status: 'archived' };
    (useAuth as any).mockReturnValue({ user: mockUser });
    (projectService.getProjectsByUserId as any).mockResolvedValue({
      data: mockProjects,
      error: null,
    });
    (projectService.updateProjectStatus as any).mockResolvedValue({
      data: updatedProject,
      error: null,
    });

    render(<ProjectProvider><TestComponent /></ProjectProvider>);

    // Wait for initial load
    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      ctx.setCurrentProject(mockProjects[0]);
    });

    // Update status
    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      return ctx.updateProjectStatus(mockProjects[0].id, 'archived');
    });

    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      const updated = ctx.projects.find(p => p.id === mockProjects[0].id);
      expect(updated?.status).toBe('archived');
      expect(ctx.currentProject?.status).toBe('archived');
    });
  });

  it('should delete a project and clear currentProject if deleted', async () => {
    (useAuth as any).mockReturnValue({ user: mockUser });
    (projectService.getProjectsByUserId as any).mockResolvedValue({
      data: mockProjects,
      error: null,
    });
    (projectService.deleteProject as any).mockResolvedValue({
      error: null,
    });

    render(<ProjectProvider><TestComponent /></ProjectProvider>);

    // Wait for initial load
    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      ctx.setCurrentProject(mockProjects[0]);
    });

    // Delete project
    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      return ctx.deleteProject(mockProjects[0].id);
    });

    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      expect(ctx.projects.some(p => p.id === mockProjects[0].id)).toBe(false);
      expect(ctx.currentProject).toBeNull();
    });
  });

  it('should return recent projects based on limit', async () => {
    (useAuth as any).mockReturnValue({ user: mockUser });
    (projectService.getProjectsByUserId as any).mockResolvedValue({
      data: mockProjects,
      error: null,
    });

    render(<ProjectProvider><TestComponent /></ProjectProvider>);

    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      const recent = ctx.getRecentProjects(1);
      expect(recent).toEqual([mockProjects[0]]);
    });
  });

  test.each([
    { limit: 0, expected: [] },
    { limit: 5, expected: mockProjects },
    { limit: -1, expected: [] },
  ])('getRecentProjects handles limit %i correctly', async ({ limit, expected }) => {
    (useAuth as any).mockReturnValue({ user: mockUser });
    (projectService.getProjectsByUserId as any).mockResolvedValue({
      data: mockProjects,
      error: null,
    });

    render(<ProjectProvider><TestComponent /></ProjectProvider>);

    await waitFor(() => {
      const ctxDiv = screen.getByTestId('context');
      const ctx = JSON.parse(ctxDiv.textContent ?? '{}');
      const recent = ctx.getRecentProjects(limit);
      expect(recent).toEqual(expected);
    });
  });
});

describe('useProject hook', () => {
  it('should throw when used outside ProjectProvider', () => {
    const TestWithoutProvider = () => {
      useProject();
      return null;
    };
    expect(() => render(<TestWithoutProvider />)).toThrow(
      'useProject must be used within a ProjectProvider'
    );
  });
});