// AUTO-GENERATED BY generate-tests.ts
// Source: src/contexts/WorkflowContext.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi, test } from 'vitest';
import { WorkflowProvider, useWorkflow } from '../../../src/contexts/WorkflowContext';
import React from 'react';

function TestComponent() {
  const {
    workflowState,
    mode,
    planSummary,
    isImplementReady,
    isPlanningMode,
    isBuildMode,
    isDefaultMode,
    enterPlanningMode,
    enterBuildMode,
    exitToDefaultMode,
    setImplementReady,
    resetWorkflow,
  } = useWorkflow();

  const dummyPlan = { tasks: 3, steps: ['step1', 'step2'] };

  return (
    <div>
      <span data-testid="mode">{mode}</span>
      <span data-testid="planSummary">{JSON.stringify(planSummary)}</span>
      <span data-testid="isImplementReady">{isImplementReady}</span>
      <span data-testid="isPlanningMode">{isPlanningMode}</span>
      <span data-testid="isBuildMode">{isBuildMode}</span>
      <span data-testid="isDefaultMode">{isDefaultMode}</span>
      <button data-testid="enterPlanning" onClick={enterPlanningMode}>Planning</button>
      <button data-testid="enterBuild" onClick={() => enterBuildMode(dummyPlan)}>Build</button>
      <button data-testid="exitDefault" onClick={exitToDefaultMode}>Exit</button>
      <button data-testid="setImplementReady" onClick={() => setImplementReady(true)}>SetReady</button>
      <button data-testid="resetWorkflow" onClick={resetWorkflow}>Reset</button>
    </div>
  );
}

describe('WorkflowContext', () => {
  it('provides default state initially', () => {
    render(
      <WorkflowProvider>
        <TestComponent />
      </WorkflowProvider>
    );

    expect(screen.getByTestId('mode')).toHaveTextContent('default');
    expect(screen.getByTestId('planSummary')).toHaveTextContent('null');
    expect(screen.getByTestId('isImplementReady')).toHaveTextContent('false');
    expect(screen.getByTestId('isPlanningMode')).toHaveTextContent('false');
    expect(screen.getByTestId('isBuildMode')).toHaveTextContent('false');
    expect(screen.getByTestId('isDefaultMode')).toHaveTextContent('true');
  });

  it('enterPlanningMode updates state correctly', () => {
    render(
      <WorkflowProvider>
        <TestComponent />
      </WorkflowProvider>
    );

    fireEvent.click(screen.getByTestId('enterPlanning'));

    expect(screen.getByTestId('mode')).toHaveTextContent('planning');
    expect(screen.getByTestId('isImplementReady')).toHaveTextContent('false');
    expect(screen.getByTestId('isPlanningMode')).toHaveTextContent('true');
    expect(screen.getByTestId('isBuildMode')).toHaveTextContent('false');
    expect(screen.getByTestId('isDefaultMode')).toHaveTextContent('false');
  });

  it('enterBuildMode updates state correctly with given planSummary', () => {
    render(
      <WorkflowProvider>
        <TestComponent />
      </WorkflowProvider>
    );

    fireEvent.click(screen.getByTestId('enterBuild'));

    expect(screen.getByTestId('mode')).toHaveTextContent('build');
    expect(screen.getByTestId('planSummary')).toHaveTextContent(JSON.stringify({ tasks: 3, steps: ['step1', 'step2'] }));
    expect(screen.getByTestId('isImplementReady')).toHaveTextContent('false');
    expect(screen.getByTestId('isBuildMode')).toHaveTextContent('true');
    expect(screen.getByTestId('isPlanningMode')).toHaveTextContent('false');
    expect(screen.getByTestId('isDefaultMode')).toHaveTextContent('false');
  });

  it('exitToDefaultMode resets mode to default', () => {
    render(
      <WorkflowProvider>
        <TestComponent />
      </WorkflowProvider>
    );

    fireEvent.click(screen.getByTestId('enterBuild'));
    fireEvent.click(screen.getByTestId('exitDefault'));

    expect(screen.getByTestId('mode')).toHaveTextContent('default');
    expect(screen.getByTestId('isDefaultMode')).toHaveTextContent('true');
    expect(screen.getByTestId('isBuildMode')).toHaveTextContent('false');
  });

  it('setImplementReady toggles isImplementReady', () => {
    render(
      <WorkflowProvider>
        <TestComponent />
      </WorkflowProvider>
    );

    fireEvent.click(screen.getByTestId('setImplementReady'));

    expect(screen.getByTestId('isImplementReady')).toHaveTextContent('true');
  });

  it('resetWorkflow restores initial state', () => {
    render(
      <WorkflowProvider>
        <TestComponent />
      </WorkflowProvider>
    );

    fireEvent.click(screen.getByTestId('enterBuild'));
    fireEvent.click(screen.getByTestId('setImplementReady'));
    fireEvent.click(screen.getByTestId('resetWorkflow'));

    expect(screen.getByTestId('mode')).toHaveTextContent('default');
    expect(screen.getByTestId('planSummary')).toHaveTextContent('null');
    expect(screen.getByTestId('isImplementReady')).toHaveTextContent('false');
    expect(screen.getByTestId('isDefaultMode')).toHaveTextContent('true');
  });

  it('useWorkflow throws error when used outside provider', () => {
    const BadComponent = () => {
      useWorkflow();
      return null;
    };
    expect(() => render(<BadComponent />)).toThrow('useWorkflow must be used within a WorkflowProvider');
  });

  test.each([
    [null, 'null'],
    [{ tasks: 5, steps: ['a', 'b', 'c'] }, JSON.stringify({ tasks: 5, steps: ['a', 'b', 'c'] })],
  ])('enterBuildMode with various planSummary values', (plan, expectedString) => {
    const CustomComponent = () => {
      const { enterBuildMode } = useWorkflow();
      return (
        <button data-testid="enterBuildCustom" onClick={() => enterBuildMode(plan)}>BuildCustom</button>
      );
    };

    render(
      <WorkflowProvider>
        <TestComponent />
        <CustomComponent />
      </WorkflowProvider>
    );

    fireEvent.click(screen.getByTestId('enterBuildCustom'));
    expect(screen.getByTestId('planSummary')).toHaveTextContent(expectedString);
  });
});