// AUTO-GENERATED BY generate-tests.ts
// Source: src/contexts/AuthContext.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { render, screen, waitFor } from '@testing-library/react';
import { vi, describe, it, expect, beforeEach } from 'vitest';
import { AuthProvider, useAuth } from '../../../../src/contexts/AuthContext';
import { supabase, refreshRealtimeAuth } from '../../../../src/lib/supabase';
import RealtimeClient, { cleanupRealtime } from '../../../../src/realtime/realtimeClient';

// Mock external dependencies
vi.mock('../../../../src/lib/supabase', () => ({
  supabase: {
    auth: {
      getSession: vi.fn(),
      signUp: vi.fn(),
      signInWithPassword: vi.fn(),
      signOut: vi.fn(),
      onAuthStateChange: vi.fn(),
    },
  },
  refreshRealtimeAuth: vi.fn(),
}));

vi.mock('../../../../src/realtime/realtimeClient', () => ({
  RealtimeClient: {
    resetInstance: vi.fn(),
  },
  cleanupRealtime: vi.fn(),
}));

// Helper component to expose Auth context values
const TestComponent = () => {
  const {
    user,
    session,
    loading,
    authReady,
    authVersion,
    signUp,
    signIn,
    signOut,
  } = useAuth();

  return (
    <div>
      <span data-testid="user">{user ? user.id : 'null'}</span>
      <span data-testid="session">{session ? session.access_token : 'null'}</span>
      <span data-testid="loading">{loading.toString()}</span>
      <span data-testid="authReady">{authReady.toString()}</span>
      <span data-testid="authVersion">{authVersion}</span>
      <button
        onClick={() => signUp('test@example.com', 'password')}
        data-testid="signUp"
      >
        signUp
      </button>
      <button
        onClick={() => signIn('test@example.com', 'password')}
        data-testid="signIn"
      >
        signIn
      </button>
      <button
        onClick={() => signOut()}
        data-testid="signOut"
      >
        signOut
      </button>
    </div>
  );
};

describe('AuthContext', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('initializes with loading true and then sets user/session from supabase', async () => {
    const mockUser = { id: 'user-1', email: 'test@example.com' };
    const mockSession = { access_token: 'token-123', user: mockUser };
    (supabase.auth.getSession as any).mockResolvedValue({ data: { session: mockSession } });

    render(<AuthProvider><TestComponent /></AuthProvider>);

    expect(screen.getByTestId('loading')).toHaveTextContent('true');

    await waitFor(() => {
      expect(screen.getByTestId('loading')).toHaveTextContent('false');
    });

    expect(screen.getByTestId('user')).toHaveTextContent(mockUser.id);
    expect(screen.getByTestId('session')).toHaveTextContent(mockSession.access_token);
    expect(screen.getByTestId('authReady')).toHaveTextContent('true');
  });

  it('signUp calls supabase.auth.signUp and returns error if any', async () => {
    (supabase.auth.signUp as any).mockResolvedValue({ error: null });

    render(<AuthProvider><TestComponent /></AuthProvider>);

    screen.getByTestId('signUp').click();

    await waitFor(() => {
      expect(supabase.auth.signUp).toHaveBeenCalledWith({
        email: 'test@example.com',
        password: 'password',
      });
    });
  });

  it('signIn calls supabase.auth.signInWithPassword and returns error if any', async () => {
    (supabase.auth.signInWithPassword as any).mockResolvedValue({ error: null });

    render(<AuthProvider><TestComponent /></AuthProvider>);

    screen.getByTestId('signIn').click();

    await waitFor(() => {
      expect(supabase.auth.signInWithPassword).toHaveBeenCalledWith({
        email: 'test@example.com',
        password: 'password',
      });
    });
  });

  it('signOut clears user/session and authReady becomes false', async () => {
    const mockUser = { id: 'user-1', email: 'test@example.com' };
    const mockSession = { access_token: 'token-123', user: mockUser };
    (supabase.auth.getSession as any).mockResolvedValue({ data: { session: mockSession } });
    (supabase.auth.signOut as any).mockResolvedValue({});

    render(<AuthProvider><TestComponent /></AuthProvider>);

    await waitFor(() => {
      expect(screen.getByTestId('authReady')).toHaveTextContent('true');
    });

    screen.getByTestId('signOut').click();

    await waitFor(() => {
      expect(supabase.auth.signOut).toHaveBeenCalled();
      expect(screen.getByTestId('user')).toHaveTextContent('null');
      expect(screen.getByTestId('session')).toHaveTextContent('null');
      expect(screen.getByTestId('authReady')).toHaveTextContent('false');
    });
  });

  it('useAuth throws when used outside AuthProvider', () => {
    const BadComponent = () => {
      // @ts-ignore
      useAuth();
      return null;
    };
    expect(() => render(<BadComponent />)).toThrow('useAuth must be used within an AuthProvider');
  });

  describe('onAuthStateChange handling', () => {
    let onAuthStateChangeCallback: (event: string, session: any) => void;

    beforeEach(() => {
      (supabase.auth.onAuthStateChange as any).mockImplementation((cb) => {
        onAuthStateChangeCallback = cb;
        return { data: { subscription: { unsubscribe: vi.fn() } } };
      });
    });

    it('handles SIGNED_OUT event correctly', async () => {
      const mockUser = { id: 'user-1', email: 'test@example.com' };
      const mockSession = { access_token: 'token-123', user: mockUser };
      (supabase.auth.getSession as any).mockResolvedValue({ data: { session: mockSession } });

      render(<AuthProvider><TestComponent /></AuthProvider>);

      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent(mockUser.id);
      });

      // Trigger SIGNED_OUT
      onAuthStateChangeCallback('SIGNED_OUT', null);

      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent('null');
        expect(screen.getByTestId('session')).toHaveTextContent('null');
        expect(screen.getByTestId('authReady')).toHaveTextContent('false');
        expect(refreshRealtimeAuth).toHaveBeenCalledWith({ forceReconnect: true, ensureConnected: true });
        expect(cleanupRealtime).toHaveBeenCalledWith('AUTH_CHANGE');
        expect(RealtimeClient.resetInstance).toHaveBeenCalled();
      });
    });

    it('handles SIGNED_IN event without user switch (session resume)', async () => {
      const mockUser = { id: 'user-1', email: 'test@example.com' };
      const mockSession = { access_token: 'token-123', user: mockUser };
      (supabase.auth.getSession as any).mockResolvedValue({ data: { session: mockSession } });

      render(<AuthProvider><TestComponent /></AuthProvider>);

      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent(mockUser.id);
      });

      // Trigger SIGNED_IN with same userId
      onAuthStateChangeCallback('SIGNED_IN', mockSession);

      await waitFor(() => {
        expect(refreshRealtimeAuth).toHaveBeenCalledWith({ forceReconnect: false, ensureConnected: true });
        expect(RealtimeClient.resetInstance).not.toHaveBeenCalled();
        expect(cleanupRealtime).not.toHaveBeenCalled();
      });
    });

    it('handles SIGNED_IN event with user switch', async () => {
      const mockUser1 = { id: 'user-1', email: 'test1@example.com' };
      const mockSession1 = { access_token: 'token-123', user: mockUser1 };
      const mockUser2 = { id: 'user-2', email: 'test2@example.com' };
      const mockSession2 = { access_token: 'token-456', user: mockUser2 };

      (supabase.auth.getSession as any).mockResolvedValue({ data: { session: mockSession1 } });

      render(<AuthProvider><TestComponent /></AuthProvider>);

      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent(mockUser1.id);
      });

      // Trigger SIGNED_IN with different userId
      onAuthStateChangeCallback('SIGNED_IN', mockSession2);

      await waitFor(() => {
        expect(refreshRealtimeAuth).toHaveBeenCalledWith({ forceReconnect: true, ensureConnected: true });
        expect(RealtimeClient.resetInstance).toHaveBeenCalled();
        expect(cleanupRealtime).toHaveBeenCalledWith('AUTH_CHANGE');
        expect(screen.getByTestId('user')).toHaveTextContent(mockUser2.id);
      });
    });

    it('handles TOKEN_REFRESHED event correctly', async () => {
      const mockUser = { id: 'user-1', email: 'test@example.com' };
      const mockSession = { access_token: 'token-123', user: mockUser };
      (supabase.auth.getSession as any).mockResolvedValue({ data: { session: mockSession } });

      render(<AuthProvider><TestComponent /></AuthProvider>);

      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent(mockUser.id);
      });

      // Trigger TOKEN_REFRESHED
      onAuthStateChangeCallback('TOKEN_REFRESHED', mockSession);

      await waitFor(() => {
        expect(refreshRealtimeAuth).toHaveBeenCalledWith({ forceReconnect: false, ensureConnected: true });
        expect(RealtimeClient.resetInstance).not.toHaveBeenCalled();
        expect(cleanupRealtime).not.toHaveBeenCalled();
      });
    });
  });
});