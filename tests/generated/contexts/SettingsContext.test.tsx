// AUTO-GENERATED BY generate-tests.ts
// Source: src/contexts/SettingsContext.tsx
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { SettingsProvider, useSettings } from '../../../src/contexts/SettingsContext';
import { ReactNode } from 'react';

const PRELOAD_STORAGE_KEY = 'aisb:preload-node-modules';

// Helper component to consume the context
function TestComponent({ children }: { children?: ReactNode }) {
  const { preloadNodeModules, setPreloadNodeModules } = useSettings();
  return (
    <div>
      <span data-testid="preload-value">{String(preloadNodeModules)}</span>
      <button
        data-testid="toggle-button"
        onClick={() => setPreloadNodeModules(!preloadNodeModules)}
      >
        Toggle
      </button>
      {children}
    </div>
  );
}

// Mock localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: vi.fn((key: string) => (key in store ? store[key] : null)),
    setItem: vi.fn((key: string, value: string) => {
      store[key] = value;
    }),
    clear: vi.fn(() => {
      store = {};
    }),
    removeItem: vi.fn((key: string) => {
      delete store[key];
    }),
  };
})();

describe('SettingsContext', () => {
  beforeEach(() => {
    // Replace the global localStorage with our mock
    Object.defineProperty(global, 'localStorage', {
      value: localStorageMock,
      writable: true,
    });
    localStorageMock.getItem.mockClear();
    localStorageMock.setItem.mockClear();
    localStorageMock.clear();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('provides default value true when localStorage has no stored value', () => {
    render(
      <SettingsProvider>
        <TestComponent />
      </SettingsProvider>
    );

    expect(screen.getByTestId('preload-value').textContent).toBe('true');
    expect(localStorageMock.getItem).toHaveBeenCalledWith(PRELOAD_STORAGE_KEY);
  });

  test.each`
    storedValue | expected
    ${null}     | ${true}
    ${'true'}   | ${true}
    ${'false'}  | ${false}
    ${'invalid'}| ${true}
  `(
    'initializes preloadNodeModules to $expected when localStorage.getItem returns $storedValue',
    ({ storedValue, expected }) => {
      localStorageMock.getItem.mockReturnValue(storedValue);
      render(
        <SettingsProvider>
          <TestComponent />
        </SettingsProvider>
      );
      expect(screen.getByTestId('preload-value').textContent).toBe(String(expected));
    }
  );

  it('updates state and writes to localStorage when setPreloadNodeModules is called', async () => {
    render(
      <SettingsProvider>
        <TestComponent />
      </SettingsProvider>
    );

    // Click toggle button to change value
    fireEvent.click(screen.getByTestId('toggle-button'));

    await waitFor(() => {
      expect(screen.getByTestId('preload-value').textContent).toBe('false');
    });

    expect(localStorageMock.setItem).toHaveBeenCalledWith(
      PRELOAD_STORAGE_KEY,
      'false'
    );
  });

  it('ignores errors from localStorage.getItem during initialization', () => {
    localStorageMock.getItem.mockImplementation(() => {
      throw new Error('Storage error');
    });

    render(
      <SettingsProvider>
        <TestComponent />
      </SettingsProvider>
    );

    expect(screen.getByTestId('preload-value').textContent).toBe('true');
    expect(localStorageMock.getItem).toHaveBeenCalled();
  });

  it('ignores errors from localStorage.setItem when setting value', async () => {
    localStorageMock.setItem.mockImplementation(() => {
      throw new Error('Quota exceeded');
    });

    render(
      <SettingsProvider>
        <TestComponent />
      </SettingsProvider>
    );

    fireEvent.click(screen.getByTestId('toggle-button'));

    await waitFor(() => {
      expect(screen.getByTestId('preload-value').textContent).toBe('false');
    });

    // Even though setItem threw, the state should still update
    expect(localStorageMock.setItem).toHaveBeenCalledWith(
      PRELOAD_STORAGE_KEY,
      'false'
    );
  });

  it('throws an error when useSettings is called outside of SettingsProvider', () => {
    const TestOutside = () => {
      useSettings();
      return null;
    };

    expect(() => render(<TestOutside />)).toThrow(
      'useSettings 必须在 SettingsProvider 内部使用'
    );
  });
});