// AUTO-GENERATED BY generate-tests.ts
// Source: src/lib/webContainerManager.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { webContainerManager } from '../../../src/lib/webContainerManager';

type MockInstance = {
  teardown: () => Promise<void>;
};

type MockProcess = {
  kill: () => void;
};

describe('webContainerManager', () => {
  const originalWindow = { ...window };

  const mockWebContainerClass = vi.fn().mockImplementation(() => ({
    boot: vi.fn().mockResolvedValue({} as MockInstance),
  }));

  const mockInstance: MockInstance = {
    teardown: vi.fn().mockResolvedValue(undefined),
  };

  const mockProcess: MockProcess = {
    kill: vi.fn(),
  };

  beforeEach(() => {
    // Reset module state
    vi.resetModules();
    // Re-import the module after reset
    vi.mock('@webcontainer/api', () => ({
      WebContainer: mockWebContainerClass,
    }));
    // Restore window properties
    Object.assign(window, originalWindow);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('isSupported', () => {
    const testCases = [
      {
        description: 'browser undefined',
        setup: () => {
          // @ts-ignore
          delete window.window;
        },
        expected: false,
        reason: 'WebContainer 需要浏览器环境',
      },
      {
        description: 'non-secure context',
        setup: () => {
          window.isSecureContext = false;
          window.location = { hostname: 'example.com' } as any;
          window.crossOriginIsolated = true;
        },
        expected: false,
        reason: 'WebContainer 需要通过 HTTPS 或在 localhost 环境下运行',
      },
      {
        description: 'cross-origin isolation disabled',
        setup: () => {
          window.isSecureContext = true;
          window.location = { hostname: 'localhost' } as any;
          window.crossOriginIsolated = false;
        },
        expected: false,
        reason: '浏览器未启用跨源隔离 (COOP/COEP)，无法加载 WebContainer 预览',
      },
      {
        description: 'secure and isolated',
        setup: () => {
          window.isSecureContext = true;
          window.location = { hostname: 'localhost' } as any;
          window.crossOriginIsolated = true;
        },
        expected: true,
        reason: null,
      },
    ];

    test.each(testCases)('$description', async ({ setup, expected, reason }) => {
      setup();
      const result = webContainerManager.isSupported();
      expect(result).toBe(expected);
      expect(webContainerManager.getUnsupportedReason()).toBe(reason);
    });
  });

  describe('loadWebContainerClass', () => {
    it('loads class when supported', async () => {
      window.isSecureContext = true;
      window.location = { hostname: 'localhost' } as any;
      window.crossOriginIsolated = true;

      const result = await webContainerManager.loadWebContainerClass();
      expect(result).toBe(true);
      expect(mockWebContainerClass).toHaveBeenCalledTimes(1);
    });

    it('does not reload if already loaded', async () => {
      window.isSecureContext = true;
      window.location = { hostname: 'localhost' } as any;
      window.crossOriginIsolated = true;

      await webContainerManager.loadWebContainerClass();
      mockWebContainerClass.mockClear();
      const result = await webContainerManager.loadWebContainerClass();
      expect(result).toBe(true);
      expect(mockWebContainerClass).not.toHaveBeenCalled();
    });

    it('fails to load when unsupported', async () => {
      // @ts-ignore
      delete window.window;
      const result = await webContainerManager.loadWebContainerClass();
      expect(result).toBe(false);
      expect(webContainerManager.getUnsupportedReason()).toBe('WebContainer 需要浏览器环境');
    });
  });

  describe('boot', () => {
    it('boots and returns instance', async () => {
      window.isSecureContext = true;
      window.location = { hostname: 'localhost' } as any;
      window.crossOriginIsolated = true;

      const instance = await webContainerManager.boot();
      expect(instance).toBeDefined();
      expect(webContainerManager.getInstance()).toBe(instance);
      expect(webContainerManager.getState()).toBe('ready');
    });

    it('returns same instance on subsequent boots', async () => {
      window.isSecureContext = true;
      window.location = { hostname: 'localhost' } as any;
      window.crossOriginIsolated = true;

      const first = await webContainerManager.boot();
      const second = await webContainerManager.boot();
      expect(second).toBe(first);
    });

    it('handles boot errors and resets state', async () => {
      window.isSecureContext = true;
      window.location = { hostname: 'localhost' } as any;
      window.crossOriginIsolated = true;

      // Mock boot to throw
      mockWebContainerClass().mockImplementationOnce(() => ({
        boot: vi.fn().mockRejectedValue(new Error('boot failed')),
      }));

      await expect(webContainerManager.boot()).rejects.toThrow('boot failed');
      expect(webContainerManager.getState()).toBe('idle');
      expect(webContainerManager.getInstance()).toBeNull();
    });
  });

  describe('teardown', () => {
    it('tears down instance and dev server', async () => {
      window.isSecureContext = true;
      window.location = { hostname: 'localhost' } as any;
      window.crossOriginIsolated = true;

      const instance = await webContainerManager.boot();
      webContainerManager.setDevServerProcess(mockProcess);

      await webContainerManager.teardown();

      expect(instance.teardown).toHaveBeenCalledTimes(1);
      expect(mockProcess.kill).toHaveBeenCalledTimes(1);
      expect(webContainerManager.getInstance()).toBeNull();
      expect(webContainerManager.getDevServerProcess()).toBeNull();
      expect(webContainerManager.getState()).toBe('idle');
    });

    it('does nothing when already idle', async () => {
      await webContainerManager.teardown();
      expect(webContainerManager.getState()).toBe('idle');
    });
  });

  describe('setDevServerProcess / getDevServerProcess', () => {
    it('sets and gets process correctly', () => {
      webContainerManager.setDevServerProcess(mockProcess);
      expect(webContainerManager.getDevServerProcess()).toBe(mockProcess);
    });

    it('clears process when set to null', () => {
      webContainerManager.setDevServerProcess(mockProcess);
      webContainerManager.setDevServerProcess(null);
      expect(webContainerManager.getDevServerProcess()).toBeNull();
    });
  });

  describe('getState', () => {
    it('returns correct state transitions', async () => {
      expect(webContainerManager.getState()).toBe('idle');
      window.isSecureContext = true;
      window.location = { hostname: 'localhost' } as any;
      window.crossOriginIsolated = true;
      const bootPromise = webContainerManager.boot();
      expect(webContainerManager.getState()).toBe('booting');
      await bootPromise;
      expect(webContainerManager.getState()).toBe('ready');
      await webContainerManager.teardown();
      expect(webContainerManager.getState()).toBe('idle');
    });
  });
});