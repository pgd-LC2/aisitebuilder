// AUTO-GENERATED BY generate-tests.ts
// Source: src/lib/supabase.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, test, vi, beforeEach, afterEach } from 'vitest';

describe('supabase module', () => {
  const validUrl = 'http://localhost';
  const validAnonKey = 'anon-key';

  // Helper to import the module after stubbing env variables
  async function importModule() {
    vi.stubEnv('VITE_SUPABASE_URL', validUrl);
    vi.stubEnv('VITE_SUPABASE_ANON_KEY', validAnonKey);
    // Clear any previous cached module
    const module = await import('../../../src/lib/supabase');
    return module;
  }

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('environment variable checks', () => {
    it('throws when VITE_SUPABASE_URL is missing', async () => {
      vi.stubEnv('VITE_SUPABASE_URL', undefined);
      vi.stubEnv('VITE_SUPABASE_ANON_KEY', validAnonKey);
      await expect(importModule()).rejects.toThrow('Missing Supabase environment variables');
    });

    it('throws when VITE_SUPABASE_ANON_KEY is missing', async () => {
      vi.stubEnv('VITE_SUPABASE_URL', validUrl);
      vi.stubEnv('VITE_SUPABASE_ANON_KEY', undefined);
      await expect(importModule()).rejects.toThrow('Missing Supabase environment variables');
    });
  });

  describe('refreshRealtimeAuth', () => {
    let supabase: any;
    let refreshRealtimeAuth: (options?: { forceReconnect?: boolean; ensureConnected?: boolean }) => Promise<void>;

    beforeEach(async () => {
      const mod = await importModule();
      supabase = mod.supabase;
      refreshRealtimeAuth = mod.refreshRealtimeAuth;

      // Mock the realtime client
      supabase.realtime = {
        setAuth: vi.fn(),
        disconnect: vi.fn(),
        connect: vi.fn(),
        socket: {
          isConnected: vi.fn().mockReturnValue(false),
          connectionState: 'open',
        },
      };

      // Mock auth.getSession
      supabase.auth = {
        getSession: vi.fn(),
      };
    });

    test.each`
      description                               | token                 | forceReconnect | ensureConnected | expectedSetAuth | expectedDisconnect | expectedConnect
      ${'token unchanged, no flags'}            | ${validAnonKey}       | ${false}       | ${false}        | ${false}        | ${false}           | ${false}
      ${'token changed'}                       | ${'new-token'}        | ${false}       | ${false}        | ${true}         | ${true}            | ${true}
      ${'forceReconnect true'}                 | ${validAnonKey}       | ${true}        | ${false}        | ${false}        | ${true}            | ${true}
      ${'ensureConnected true, socket closed'}  | ${validAnonKey}       | ${false}       | ${true}         | ${false}        | ${true}            | ${true}
    `('behaves correctly when $description', async ({
      token,
      forceReconnect,
      ensureConnected,
      expectedSetAuth,
      expectedDisconnect,
      expectedConnect,
    }) => {
      // Arrange
      supabase.auth.getSession.mockResolvedValue({ data: { session: { access_token: token } } });
      // Ensure socket is closed for ensureConnected test
      supabase.realtime.socket.isConnected.mockReturnValue(!ensureConnected);

      // Act
      await refreshRealtimeAuth({ forceReconnect, ensureConnected });

      // Assert
      if (expectedSetAuth) {
        expect(supabase.realtime.setAuth).toHaveBeenCalledWith(token);
      } else {
        expect(supabase.realtime.setAuth).not.toHaveBeenCalled();
      }

      if (expectedDisconnect) {
        expect(supabase.realtime.disconnect).toHaveBeenCalled();
      } else {
        expect(supabase.realtime.disconnect).not.toHaveBeenCalled();
      }

      if (expectedConnect) {
        expect(supabase.realtime.connect).toHaveBeenCalled();
      } else {
        expect(supabase.realtime.connect).not.toHaveBeenCalled();
      }
    });

    it('uses supabaseAnonKey when session token is undefined', async () => {
      // Arrange
      supabase.auth.getSession.mockResolvedValue({ data: { session: {} } });

      // Act
      await refreshRealtimeAuth();

      // Assert
      expect(supabase.realtime.setAuth).toHaveBeenCalledWith(validAnonKey);
    });

    it('prevents concurrent executions by returning the same promise', async () => {
      // Arrange
      supabase.auth.getSession.mockResolvedValue({ data: { session: { access_token: 'token-1' } } });

      // Act
      const promise1 = refreshRealtimeAuth();
      const promise2 = refreshRealtimeAuth();

      // Both promises should be the same instance
      expect(promise2).toBe(promise1);

      // Await completion
      await promise1;

      // After completion, disconnect and connect should have been called once
      expect(supabase.realtime.disconnect).toHaveBeenCalledTimes(1);
      expect(supabase.realtime.connect).toHaveBeenCalledTimes(1);
    });
  });
});