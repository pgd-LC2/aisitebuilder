// AUTO-GENERATED BY generate-tests.ts
// Source: src/lib/nodeModulesCache.ts
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖

import { describe, it, expect, test, vi, beforeEach, afterEach } from 'vitest';
import {
  loadNodeModulesSnapshot,
  saveNodeModulesSnapshot,
  clearNodeModulesCache,
} from '../../../src/lib/nodeModulesCache';

type CacheRecord = {
  key: string;
  data: string;
  timestamp: number;
};

let storeMap: Map<string, CacheRecord>;

function createMockIndexedDB() {
  storeMap = new Map<string, CacheRecord>();

  const mockDB = {
    transaction: (storeName: string, mode: string) => {
      const store = {
        put: (record: CacheRecord) => {
          storeMap.set(record.key, record);
        },
        get: (key: string) => {
          return storeMap.get(key) ?? null;
        },
        delete: (key: string) => {
          storeMap.delete(key);
        },
        clear: () => {
          storeMap.clear();
        },
        getAll: () => {
          return Array.from(storeMap.values());
        },
      };
      const tx = {
        objectStore: () => store,
        oncomplete: null as (() => void) | null,
        onerror: null as ((e: any) => void) | null,
        onabort: null as ((e: any) => void) | null,
      };
      return tx;
    },
  };

  const open = (name: string, version: number) => {
    const request = {
      result: mockDB,
      onsuccess: null as (() => void) | null,
      onerror: null as ((e: any) => void) | null,
      onupgradeneeded: null as (() => void) | null,
    };
    // Simulate async success
    setTimeout(() => {
      request.onsuccess?.();
    }, 0);
    return request;
  };

  return { open };
}

beforeEach(() => {
  const mockIndexedDB = createMockIndexedDB();
  // @ts-ignore
  globalThis.window = {
    indexedDB: mockIndexedDB,
  };
});

afterEach(() => {
  // Clean up global window
  // @ts-ignore
  delete globalThis.window;
});

describe('nodeModulesCache', () => {
  describe('saveNodeModulesSnapshot & loadNodeModulesSnapshot', () => {
    const snapshots = [
      { key: 'empty', data: new Uint8Array([]) },
      { key: 'single', data: new Uint8Array([0x41]) }, // 'A'
      { key: 'multiple', data: new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]) }, // 'Hello'
      {
        key: 'large',
        data: new Uint8Array(1000).fill(0x42), // 1000 bytes of 'B'
      },
    ];

    test.each(snapshots)('should save and load snapshot for key "$key"', async ({ key, data }) => {
      // Arrange
      await saveNodeModulesSnapshot(key, data);

      // Act
      const loaded = await loadNodeModulesSnapshot(key);

      // Assert
      expect(loaded).toBeInstanceOf(Uint8Array);
      expect(loaded?.length).toBe(data.length);
      expect(loaded).toEqual(data);
    });

    it('should return null for falsy key', async () => {
      const result = await loadNodeModulesSnapshot('');
      expect(result).toBeNull();
    });

    it('should return a copy of the snapshot (not the same reference)', async () => {
      const key = 'copy-test';
      const original = new Uint8Array([1, 2, 3]);
      await saveNodeModulesSnapshot(key, original);

      const loaded = await loadNodeModulesSnapshot(key);
      expect(loaded).not.toBe(original);
      expect(loaded).toEqual(original);
    });
  });

  describe('clearNodeModulesCache', () => {
    const key = 'clear-test';
    const data = new Uint8Array([9, 9, 9]);

    beforeEach(async () => {
      await saveNodeModulesSnapshot(key, data);
    });

    it('should clear specific key from in-memory cache and persisted storage', async () => {
      // Ensure loaded
      const loadedBefore = await loadNodeModulesSnapshot(key);
      expect(loadedBefore).toEqual(data);

      // Clear
      await clearNodeModulesCache(key);

      // In-memory cache should be cleared
      const loadedAfter = await loadNodeModulesSnapshot(key);
      expect(loadedAfter).toBeNull();
    });

    it('should clear entire cache when no key is provided', async () => {
      const key2 = 'another-key';
      const data2 = new Uint8Array([5, 6, 7]);
      await saveNodeModulesSnapshot(key2, data2);

      // Ensure both are loaded
      expect(await loadNodeModulesSnapshot(key)).toEqual(data);
      expect(await loadNodeModulesSnapshot(key2)).toEqual(data2);

      // Clear all
      await clearNodeModulesCache();

      expect(await loadNodeModulesSnapshot(key)).toBeNull();
      expect(await loadNodeModulesSnapshot(key2)).toBeNull();
    });
  });

  describe('cleanupOldRecords (implicit test)', () => {
    const keys = ['first', 'second', 'third'];
    const data = new Uint8Array([0x41]);

    beforeEach(async () => {
      // Save three records sequentially
      for (const k of keys) {
        await saveNodeModulesSnapshot(k, data);
        // Small delay to ensure timestamp difference
        await new Promise((r) => setTimeout(r, 10));
      }
    });

    it('should keep only the most recent MAX_PERSISTED_RECORDS records', async () => {
      // The oldest record ('first') should be removed
      await clearNodeModulesCache('first');
      const loadedFirst = await loadNodeModulesSnapshot('first');
      expect(loadedFirst).toBeNull();

      // The other two should still be available
      await clearNodeModulesCache('second');
      const loadedSecond = await loadNodeModulesSnapshot('second');
      expect(loadedSecond).toEqual(data);

      await clearNodeModulesCache('third');
      const loadedThird = await loadNodeModulesSnapshot('third');
      expect(loadedThird).toEqual(data);
    });
  });
});