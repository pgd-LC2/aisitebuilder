#!/usr/bin/env npx ts-node
/**
 * AI 自动测试生成器
 * 
 * 功能：
 * - 扫描 src/ 目录下的所有 TypeScript 文件
 * - 使用 OpenRouter API (google/gemini-3-pro-preview) 生成测试代码
 * - 通过哈希缓存实现增量更新（只更新变化的文件）
 * - 将生成的测试放在 tests/generated/ 目录下
 * 
 * 使用方法：
 * - npm run test:gen          # 生成所有测试
 * - npm run test:gen:watch    # 监听模式
 * - npm run test:gen -- --force  # 强制重新生成所有测试
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

// 配置
const CONFIG = {
  srcDir: 'src',
  testsDir: 'tests/generated',
  metaFile: 'tests/.generated-tests-meta.json',
  openRouterEndpoint: 'https://openrouter.ai/api/v1/chat/completions',
  model: 'inception/mercury-coder',
  excludePatterns: [
    /\.d\.ts$/,
    /main\.tsx$/,
    /vite-env\.d\.ts$/,
    /index\.ts$/,
    /index\.tsx$/,
  ],
  // 优先生成测试的目录（纯函数、工具类）
  priorityDirs: ['utils', 'lib'],
  // 需要特殊处理的目录（React 组件、服务等）
  componentDirs: ['components'],
  serviceDirs: ['services', 'realtime'],
};

// 元数据类型
interface TestMeta {
  sourceHash: string;
  testPath: string;
  generatedAt: string;
  model: string;
}

interface MetaData {
  version: string;
  files: Record<string, TestMeta>;
}

// 颜色输出
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
};

function log(message: string, color: keyof typeof colors = 'reset'): void {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// 计算文件内容哈希
function computeHash(content: string): string {
  return crypto.createHash('sha256').update(content).digest('hex').slice(0, 16);
}

// 读取元数据
function loadMeta(): MetaData {
  const metaPath = path.join(process.cwd(), CONFIG.metaFile);
  if (fs.existsSync(metaPath)) {
    try {
      return JSON.parse(fs.readFileSync(metaPath, 'utf-8'));
    } catch {
      return { version: '1.0', files: {} };
    }
  }
  return { version: '1.0', files: {} };
}

// 保存元数据
function saveMeta(meta: MetaData): void {
  const metaPath = path.join(process.cwd(), CONFIG.metaFile);
  fs.writeFileSync(metaPath, JSON.stringify(meta, null, 2));
}

// 扫描源文件
function scanSourceFiles(): string[] {
  const srcPath = path.join(process.cwd(), CONFIG.srcDir);
  const files: string[] = [];

  function walk(dir: string): void {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        walk(fullPath);
      } else if (entry.isFile() && /\.(ts|tsx)$/.test(entry.name)) {
        const relativePath = path.relative(process.cwd(), fullPath);
        // 检查是否应该排除
        const shouldExclude = CONFIG.excludePatterns.some(pattern => pattern.test(relativePath));
        if (!shouldExclude) {
          files.push(relativePath);
        }
      }
    }
  }

  walk(srcPath);
  return files.sort();
}

// 获取测试文件路径
function getTestPath(sourcePath: string): string {
  // src/utils/foo.ts -> tests/generated/utils/foo.test.ts
  const relativePath = sourcePath.replace(/^src\//, '');
  const ext = path.extname(relativePath);
  const baseName = relativePath.slice(0, -ext.length);
  return path.join(CONFIG.testsDir, `${baseName}.test${ext}`);
}

// 判断文件类型
function getFileType(sourcePath: string): 'util' | 'component' | 'service' | 'context' | 'other' {
  if (sourcePath.includes('/utils/') || sourcePath.includes('/lib/')) {
    return 'util';
  }
  if (sourcePath.includes('/components/')) {
    return 'component';
  }
  if (sourcePath.includes('/services/') || sourcePath.includes('/realtime/')) {
    return 'service';
  }
  if (sourcePath.includes('/contexts/')) {
    return 'context';
  }
  return 'other';
}

// 生成系统提示
function getSystemPrompt(): string {
  return `你是一个专业的 TypeScript 测试工程师。你的任务是为给定的源代码生成高质量的 Vitest 单元测试。

## 测试规范

1. **BDD 风格**：使用 describe/it/test 组织测试，描述应清晰表达被测试的行为
2. **AAA 模式**：每个测试遵循 Arrange-Act-Assert 模式
3. **参数化测试**：使用 test.each 覆盖多种输入情况
4. **边界情况**：覆盖空值、极大值、极小值、特殊字符等边界情况

## 技术要求

1. 使用 Vitest 的 describe, it, expect, test, vi 等 API
2. 对于 React 组件，使用 @testing-library/react 的 render, screen, fireEvent
3. 对于异步代码，使用 async/await 和 waitFor
4. 对于外部依赖（如 Supabase、fetch），使用 vi.mock 进行模拟
5. 不要访问真实网络或数据库
6. **重要**：导入源文件时必须使用相对路径，例如 import { foo } from '../../../src/utils/foo'，不要使用 @ 别名

## 输出格式

只输出 TypeScript 测试代码，不要有任何解释文字。代码应该可以直接保存为 .test.ts 文件并运行。

测试文件开头必须包含以下注释：
\`\`\`
// AUTO-GENERATED BY generate-tests.ts
// Source: {源文件路径}
// DO NOT EDIT MANUALLY - 修改将在下次生成时被覆盖
\`\`\``;
}

// 生成用户提示
function getUserPrompt(sourcePath: string, sourceCode: string, fileType: string): string {
  const testPath = getTestPath(sourcePath);
  
  let additionalInstructions = '';
  
  if (fileType === 'component') {
    additionalInstructions = `
## React 组件测试要求
- 使用 @testing-library/react 进行渲染测试
- 测试组件的渲染输出、用户交互、状态变化
- 模拟所有外部依赖（Context、hooks、API 调用）
- 使用 screen.getByRole, screen.getByText 等语义化查询`;
  } else if (fileType === 'service') {
    additionalInstructions = `
## 服务层测试要求
- 模拟所有外部 API 调用（Supabase、fetch 等）
- 测试成功和失败场景
- 测试边界情况和错误处理
- 使用 vi.mock 模拟依赖模块`;
  } else if (fileType === 'util') {
    additionalInstructions = `
## 工具函数测试要求
- 测试所有导出的函数
- 使用参数化测试覆盖多种输入
- 重点测试边界情况
- 确保测试是确定性的（不依赖随机数或时间）`;
  }

  return `请为以下源文件生成完整的 Vitest 单元测试：

## 源文件路径
${sourcePath}

## 测试文件路径
${testPath}

## 源代码
\`\`\`typescript
${sourceCode}
\`\`\`
${additionalInstructions}

请生成完整的测试代码。`;
}

// 调用 OpenRouter API
async function callOpenRouter(systemPrompt: string, userPrompt: string): Promise<string> {
  const apiKey = process.env.OPENROUTER_KEY;
  if (!apiKey) {
    throw new Error('OPENROUTER_KEY 环境变量未设置');
  }

  const response = await fetch(CONFIG.openRouterEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`,
      'HTTP-Referer': 'https://github.com/pgd-LC2/aisitebuilder',
      'X-Title': 'AI Site Builder Test Generator',
    },
    body: JSON.stringify({
      model: CONFIG.model,
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      temperature: 0.3,
      max_tokens: 16000,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`OpenRouter API 错误: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  const content = data.choices?.[0]?.message?.content;
  
  if (!content) {
    throw new Error('OpenRouter API 返回空内容');
  }

  // 提取代码块（如果有）
  // 尝试多种代码块格式，使用贪婪匹配获取最长的代码块
  const codeBlockPatterns = [
    /```(?:typescript|tsx?)\s*\n([\s\S]*?)```/g,
    /```\s*\n([\s\S]*?)```/g,
  ];
  
  for (const pattern of codeBlockPatterns) {
    const matches = [...content.matchAll(pattern)];
    if (matches.length > 0) {
      // 获取最长的代码块
      let longestCode = '';
      for (const match of matches) {
        if (match[1] && match[1].trim().length > longestCode.length) {
          longestCode = match[1].trim();
        }
      }
      if (longestCode.length > 50) {
        // 验证是否看起来像有效的测试代码
        if (longestCode.includes('import') || longestCode.includes('describe') || longestCode.includes('test') || longestCode.includes('it(')) {
          return longestCode;
        }
      }
    }
  }
  
  // 如果没有代码块，检查内容本身是否是有效代码
  let trimmedContent = content.trim();
  
  // 移除可能残留的 markdown 代码块标记
  trimmedContent = trimmedContent.replace(/^```(?:typescript|tsx?)?\s*\n?/, '').replace(/\n?```\s*$/, '');
  
  if (trimmedContent.includes('import') && (trimmedContent.includes('describe') || trimmedContent.includes('test'))) {
    return trimmedContent;
  }
  
  // 如果内容看起来不像有效的测试代码，抛出错误
  throw new Error(`AI 返回的内容不是有效的测试代码。内容预览: ${trimmedContent.slice(0, 200)}...`);
}

// 生成单个文件的测试
async function generateTestForFile(
  sourcePath: string,
  meta: MetaData,
  force: boolean
): Promise<{ status: 'generated' | 'skipped' | 'error'; message: string }> {
  const sourceCode = fs.readFileSync(sourcePath, 'utf-8');
  const currentHash = computeHash(sourceCode);
  const testPath = getTestPath(sourcePath);
  const fileType = getFileType(sourcePath);

  // 检查是否需要更新
  const existingMeta = meta.files[sourcePath];
  if (!force && existingMeta && existingMeta.sourceHash === currentHash && fs.existsSync(testPath)) {
    return { status: 'skipped', message: '文件未变化' };
  }

  try {
    log(`  生成测试: ${sourcePath}`, 'cyan');
    
    const systemPrompt = getSystemPrompt();
    const userPrompt = getUserPrompt(sourcePath, sourceCode, fileType);
    
    const testCode = await callOpenRouter(systemPrompt, userPrompt);
    
    // 确保目录存在
    const testDir = path.dirname(testPath);
    fs.mkdirSync(testDir, { recursive: true });
    
    // 写入测试文件
    fs.writeFileSync(testPath, testCode);
    
    // 更新元数据
    meta.files[sourcePath] = {
      sourceHash: currentHash,
      testPath,
      generatedAt: new Date().toISOString(),
      model: CONFIG.model,
    };

    return { status: 'generated', message: '成功生成' };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return { status: 'error', message: errorMessage };
  }
}

// 清理已删除源文件对应的测试
function cleanupStaleTests(sourceFiles: string[], meta: MetaData): number {
  const sourceSet = new Set(sourceFiles);
  let cleaned = 0;

  for (const [sourcePath, testMeta] of Object.entries(meta.files)) {
    if (!sourceSet.has(sourcePath)) {
      // 源文件已删除，清理测试文件和元数据
      if (fs.existsSync(testMeta.testPath)) {
        fs.unlinkSync(testMeta.testPath);
        log(`  清理: ${testMeta.testPath}`, 'yellow');
        cleaned++;
      }
      delete meta.files[sourcePath];
    }
  }

  return cleaned;
}

// 主函数
async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const force = args.includes('--force');
  const watchMode = args.includes('--watch');
  const specificFile = args.find(arg => !arg.startsWith('--'));

  log('\n=== AI 自动测试生成器 ===\n', 'cyan');

  if (!process.env.OPENROUTER_KEY) {
    log('错误: OPENROUTER_KEY 环境变量未设置', 'red');
    log('请设置环境变量后重试: export OPENROUTER_KEY=your_key', 'gray');
    process.exit(1);
  }

  // 加载元数据
  const meta = loadMeta();

  // 扫描源文件
  let sourceFiles = scanSourceFiles();
  
  if (specificFile) {
    sourceFiles = sourceFiles.filter(f => f.includes(specificFile));
    if (sourceFiles.length === 0) {
      log(`未找到匹配的文件: ${specificFile}`, 'red');
      process.exit(1);
    }
  }

  log(`扫描到 ${sourceFiles.length} 个源文件`, 'gray');

  // 清理已删除的测试
  const cleaned = cleanupStaleTests(sourceFiles, meta);
  if (cleaned > 0) {
    log(`清理了 ${cleaned} 个过期测试文件`, 'yellow');
  }

  // 统计
  let generated = 0;
  let skipped = 0;
  let errors = 0;

  // 按优先级排序：utils/lib 优先
  sourceFiles.sort((a, b) => {
    const aIsPriority = CONFIG.priorityDirs.some(dir => a.includes(`/${dir}/`));
    const bIsPriority = CONFIG.priorityDirs.some(dir => b.includes(`/${dir}/`));
    if (aIsPriority && !bIsPriority) return -1;
    if (!aIsPriority && bIsPriority) return 1;
    return 0;
  });

  // 生成测试
  for (const sourcePath of sourceFiles) {
    const result = await generateTestForFile(sourcePath, meta, force);
    
    switch (result.status) {
      case 'generated':
        log(`  [OK] ${sourcePath}`, 'green');
        generated++;
        break;
      case 'skipped':
        log(`  [跳过] ${sourcePath} - ${result.message}`, 'gray');
        skipped++;
        break;
      case 'error':
        log(`  [错误] ${sourcePath} - ${result.message}`, 'red');
        errors++;
        break;
    }

    // 保存元数据（每个文件后保存，防止中断丢失进度）
    saveMeta(meta);

    // 添加延迟避免 API 限流
    if (result.status === 'generated') {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  // 输出统计
  log('\n=== 生成完成 ===', 'cyan');
  log(`生成: ${generated} | 跳过: ${skipped} | 错误: ${errors}`, 'gray');

  if (errors > 0) {
    log('\n部分文件生成失败，请检查错误信息', 'yellow');
  }

  // Watch 模式
  if (watchMode) {
    log('\n监听文件变化中... (Ctrl+C 退出)', 'cyan');
    
    const chokidar = await import('chokidar');
    const watcher = chokidar.watch(`${CONFIG.srcDir}/**/*.{ts,tsx}`, {
      ignored: CONFIG.excludePatterns,
      persistent: true,
    });

    watcher.on('change', async (filePath: string) => {
      const relativePath = path.relative(process.cwd(), filePath);
      log(`\n文件变化: ${relativePath}`, 'yellow');
      
      const result = await generateTestForFile(relativePath, meta, true);
      if (result.status === 'generated') {
        log(`  [OK] 测试已更新`, 'green');
      } else if (result.status === 'error') {
        log(`  [错误] ${result.message}`, 'red');
      }
      saveMeta(meta);
    });

    watcher.on('add', async (filePath: string) => {
      const relativePath = path.relative(process.cwd(), filePath);
      // 检查是否应该排除
      const shouldExclude = CONFIG.excludePatterns.some(pattern => pattern.test(relativePath));
      if (shouldExclude) return;

      log(`\n新文件: ${relativePath}`, 'yellow');
      const result = await generateTestForFile(relativePath, meta, true);
      if (result.status === 'generated') {
        log(`  [OK] 测试已生成`, 'green');
      } else if (result.status === 'error') {
        log(`  [错误] ${result.message}`, 'red');
      }
      saveMeta(meta);
    });

    watcher.on('unlink', (filePath: string) => {
      const relativePath = path.relative(process.cwd(), filePath);
      const testPath = getTestPath(relativePath);
      
      if (fs.existsSync(testPath)) {
        fs.unlinkSync(testPath);
        log(`\n删除测试: ${testPath}`, 'yellow');
      }
      delete meta.files[relativePath];
      saveMeta(meta);
    });
  }
}

main().catch(error => {
  log(`致命错误: ${error.message}`, 'red');
  process.exit(1);
});
